<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>为什么用Node.js | 木易東</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link,[object Object] 0="meta" 1="[object Object]"></link,[object Object]>
    <meta name="description" content="路漫漫其修远兮，吾将上下而求索">
    <link rel="preload" href="/assets/css/0.styles.ee4150ce.css" as="style"><link rel="preload" href="/assets/js/app.4ab909ce.js" as="script"><link rel="preload" href="/assets/js/2.268f4e54.js" as="script"><link rel="preload" href="/assets/js/133.17e53083.js" as="script"><link rel="prefetch" href="/assets/js/10.209d185b.js"><link rel="prefetch" href="/assets/js/100.ed3b3fa7.js"><link rel="prefetch" href="/assets/js/101.0bc6f23b.js"><link rel="prefetch" href="/assets/js/102.266baf3f.js"><link rel="prefetch" href="/assets/js/103.41770349.js"><link rel="prefetch" href="/assets/js/104.d6b11437.js"><link rel="prefetch" href="/assets/js/105.12842ff7.js"><link rel="prefetch" href="/assets/js/106.ff323f9e.js"><link rel="prefetch" href="/assets/js/107.275a0c10.js"><link rel="prefetch" href="/assets/js/108.5b919ed5.js"><link rel="prefetch" href="/assets/js/109.332c56e1.js"><link rel="prefetch" href="/assets/js/11.f3d69358.js"><link rel="prefetch" href="/assets/js/110.e88d5e3b.js"><link rel="prefetch" href="/assets/js/111.098714a4.js"><link rel="prefetch" href="/assets/js/112.fc7ba3e2.js"><link rel="prefetch" href="/assets/js/113.a08c2b6f.js"><link rel="prefetch" href="/assets/js/114.c4d0f581.js"><link rel="prefetch" href="/assets/js/115.317cb7ca.js"><link rel="prefetch" href="/assets/js/116.97e580b5.js"><link rel="prefetch" href="/assets/js/117.121ea3ac.js"><link rel="prefetch" href="/assets/js/118.a0665182.js"><link rel="prefetch" href="/assets/js/119.7325dcf0.js"><link rel="prefetch" href="/assets/js/12.df591af5.js"><link rel="prefetch" href="/assets/js/120.326b52e9.js"><link rel="prefetch" href="/assets/js/121.f8bc07cd.js"><link rel="prefetch" href="/assets/js/122.3cb1ec13.js"><link rel="prefetch" href="/assets/js/123.ab44e19c.js"><link rel="prefetch" href="/assets/js/124.ef229142.js"><link rel="prefetch" href="/assets/js/125.c7c6e12d.js"><link rel="prefetch" href="/assets/js/126.442fa3e6.js"><link rel="prefetch" href="/assets/js/127.b36113ef.js"><link rel="prefetch" href="/assets/js/128.a489ffc0.js"><link rel="prefetch" href="/assets/js/129.ed5adff8.js"><link rel="prefetch" href="/assets/js/13.9ab5db74.js"><link rel="prefetch" href="/assets/js/130.41c2a9b4.js"><link rel="prefetch" href="/assets/js/131.1ea71563.js"><link rel="prefetch" href="/assets/js/132.0f926da5.js"><link rel="prefetch" href="/assets/js/134.382858c4.js"><link rel="prefetch" href="/assets/js/135.03feac86.js"><link rel="prefetch" href="/assets/js/136.60959adc.js"><link rel="prefetch" href="/assets/js/137.cc05055e.js"><link rel="prefetch" href="/assets/js/138.6e37fdbd.js"><link rel="prefetch" href="/assets/js/139.53f853a7.js"><link rel="prefetch" href="/assets/js/14.d8bf8180.js"><link rel="prefetch" href="/assets/js/140.c87f4519.js"><link rel="prefetch" href="/assets/js/141.2284d2b3.js"><link rel="prefetch" href="/assets/js/142.55320a45.js"><link rel="prefetch" href="/assets/js/143.fdfacb09.js"><link rel="prefetch" href="/assets/js/144.152e977e.js"><link rel="prefetch" href="/assets/js/145.0498b272.js"><link rel="prefetch" href="/assets/js/146.dd4b2b24.js"><link rel="prefetch" href="/assets/js/147.c2b141cf.js"><link rel="prefetch" href="/assets/js/148.edf0d726.js"><link rel="prefetch" href="/assets/js/149.72f09253.js"><link rel="prefetch" href="/assets/js/15.386b2793.js"><link rel="prefetch" href="/assets/js/150.39b686e7.js"><link rel="prefetch" href="/assets/js/151.6ddc4eba.js"><link rel="prefetch" href="/assets/js/152.47d4d5d0.js"><link rel="prefetch" href="/assets/js/153.93edd93b.js"><link rel="prefetch" href="/assets/js/154.ed8a1efe.js"><link rel="prefetch" href="/assets/js/155.84069324.js"><link rel="prefetch" href="/assets/js/156.0981fa5b.js"><link rel="prefetch" href="/assets/js/157.b4b037d6.js"><link rel="prefetch" href="/assets/js/158.de7f19e2.js"><link rel="prefetch" href="/assets/js/159.5552f303.js"><link rel="prefetch" href="/assets/js/16.16143f64.js"><link rel="prefetch" href="/assets/js/160.aac84d1a.js"><link rel="prefetch" href="/assets/js/161.57acc46e.js"><link rel="prefetch" href="/assets/js/162.17be9e3e.js"><link rel="prefetch" href="/assets/js/163.7d0b5f23.js"><link rel="prefetch" href="/assets/js/164.0090922d.js"><link rel="prefetch" href="/assets/js/165.ef7c2a2e.js"><link rel="prefetch" href="/assets/js/166.5a56227f.js"><link rel="prefetch" href="/assets/js/167.0695d6d5.js"><link rel="prefetch" href="/assets/js/168.e718301b.js"><link rel="prefetch" href="/assets/js/169.0dfae1c1.js"><link rel="prefetch" href="/assets/js/17.560a3e0a.js"><link rel="prefetch" href="/assets/js/170.2c0cdfce.js"><link rel="prefetch" href="/assets/js/171.290835f2.js"><link rel="prefetch" href="/assets/js/172.6e354475.js"><link rel="prefetch" href="/assets/js/173.35718045.js"><link rel="prefetch" href="/assets/js/174.55e350a8.js"><link rel="prefetch" href="/assets/js/175.7fe8e56c.js"><link rel="prefetch" href="/assets/js/176.5bf41792.js"><link rel="prefetch" href="/assets/js/177.51b9503f.js"><link rel="prefetch" href="/assets/js/178.7f4c1269.js"><link rel="prefetch" href="/assets/js/179.7bb26f94.js"><link rel="prefetch" href="/assets/js/18.6c788be1.js"><link rel="prefetch" href="/assets/js/180.c6f48737.js"><link rel="prefetch" href="/assets/js/181.6f40d208.js"><link rel="prefetch" href="/assets/js/182.cc8d6d4a.js"><link rel="prefetch" href="/assets/js/183.17deaed8.js"><link rel="prefetch" href="/assets/js/184.483c498a.js"><link rel="prefetch" href="/assets/js/185.f175ff65.js"><link rel="prefetch" href="/assets/js/186.9af453a8.js"><link rel="prefetch" href="/assets/js/187.bede2d0f.js"><link rel="prefetch" href="/assets/js/188.323ce242.js"><link rel="prefetch" href="/assets/js/189.1a925619.js"><link rel="prefetch" href="/assets/js/19.b2e312a4.js"><link rel="prefetch" href="/assets/js/190.4d691d6a.js"><link rel="prefetch" href="/assets/js/191.5a781b2d.js"><link rel="prefetch" href="/assets/js/192.1ffd0916.js"><link rel="prefetch" href="/assets/js/193.7ec310d1.js"><link rel="prefetch" href="/assets/js/194.d47c85ca.js"><link rel="prefetch" href="/assets/js/195.84c82c66.js"><link rel="prefetch" href="/assets/js/196.c77dc4ad.js"><link rel="prefetch" href="/assets/js/197.8a07281c.js"><link rel="prefetch" href="/assets/js/198.86f529c1.js"><link rel="prefetch" href="/assets/js/199.15e8d4c3.js"><link rel="prefetch" href="/assets/js/20.4d25735a.js"><link rel="prefetch" href="/assets/js/200.b3c8df9d.js"><link rel="prefetch" href="/assets/js/201.d83e7de9.js"><link rel="prefetch" href="/assets/js/202.05586c6f.js"><link rel="prefetch" href="/assets/js/203.2ea42e2f.js"><link rel="prefetch" href="/assets/js/204.41b1e1cb.js"><link rel="prefetch" href="/assets/js/205.cd69877a.js"><link rel="prefetch" href="/assets/js/206.be348d56.js"><link rel="prefetch" href="/assets/js/207.b9e8002f.js"><link rel="prefetch" href="/assets/js/208.962350ff.js"><link rel="prefetch" href="/assets/js/209.4fd61d0c.js"><link rel="prefetch" href="/assets/js/21.63d223ed.js"><link rel="prefetch" href="/assets/js/210.cc8c457c.js"><link rel="prefetch" href="/assets/js/211.d251ee9f.js"><link rel="prefetch" href="/assets/js/212.5007cefb.js"><link rel="prefetch" href="/assets/js/213.d33d9f03.js"><link rel="prefetch" href="/assets/js/214.503c33ec.js"><link rel="prefetch" href="/assets/js/215.df94bc76.js"><link rel="prefetch" href="/assets/js/216.163a50bd.js"><link rel="prefetch" href="/assets/js/217.21b20dbb.js"><link rel="prefetch" href="/assets/js/218.edf914d2.js"><link rel="prefetch" href="/assets/js/219.6b54dbc4.js"><link rel="prefetch" href="/assets/js/22.42386486.js"><link rel="prefetch" href="/assets/js/220.b344f421.js"><link rel="prefetch" href="/assets/js/221.d93c8092.js"><link rel="prefetch" href="/assets/js/222.8e918999.js"><link rel="prefetch" href="/assets/js/223.671a27bc.js"><link rel="prefetch" href="/assets/js/224.53c00cb7.js"><link rel="prefetch" href="/assets/js/225.615e5576.js"><link rel="prefetch" href="/assets/js/226.d7d4d768.js"><link rel="prefetch" href="/assets/js/227.8dafb796.js"><link rel="prefetch" href="/assets/js/228.7312b790.js"><link rel="prefetch" href="/assets/js/229.f5724c5b.js"><link rel="prefetch" href="/assets/js/23.ee235590.js"><link rel="prefetch" href="/assets/js/230.5be9199b.js"><link rel="prefetch" href="/assets/js/231.6b143716.js"><link rel="prefetch" href="/assets/js/24.51c34572.js"><link rel="prefetch" href="/assets/js/25.e697ec23.js"><link rel="prefetch" href="/assets/js/26.246009e9.js"><link rel="prefetch" href="/assets/js/27.d4c92ad1.js"><link rel="prefetch" href="/assets/js/28.2ba95f3c.js"><link rel="prefetch" href="/assets/js/29.9772506d.js"><link rel="prefetch" href="/assets/js/3.ff5569b2.js"><link rel="prefetch" href="/assets/js/30.dae831a7.js"><link rel="prefetch" href="/assets/js/31.9ac2092a.js"><link rel="prefetch" href="/assets/js/32.3c2776c5.js"><link rel="prefetch" href="/assets/js/33.95a0d7b7.js"><link rel="prefetch" href="/assets/js/34.a145664d.js"><link rel="prefetch" href="/assets/js/35.357ff9ec.js"><link rel="prefetch" href="/assets/js/36.1594f674.js"><link rel="prefetch" href="/assets/js/37.5045d89d.js"><link rel="prefetch" href="/assets/js/38.a87807f8.js"><link rel="prefetch" href="/assets/js/39.22360d3d.js"><link rel="prefetch" href="/assets/js/4.cab6e33f.js"><link rel="prefetch" href="/assets/js/40.ed8d7ea6.js"><link rel="prefetch" href="/assets/js/41.86dc2857.js"><link rel="prefetch" href="/assets/js/42.2719d1a7.js"><link rel="prefetch" href="/assets/js/43.1121877d.js"><link rel="prefetch" href="/assets/js/44.d2894bdb.js"><link rel="prefetch" href="/assets/js/45.a4f59145.js"><link rel="prefetch" href="/assets/js/46.e91142f2.js"><link rel="prefetch" href="/assets/js/47.6120f6e3.js"><link rel="prefetch" href="/assets/js/48.36593726.js"><link rel="prefetch" href="/assets/js/49.280a435b.js"><link rel="prefetch" href="/assets/js/5.db6eddb9.js"><link rel="prefetch" href="/assets/js/50.ac5aa141.js"><link rel="prefetch" href="/assets/js/51.ec413eaa.js"><link rel="prefetch" href="/assets/js/52.3b4de5ad.js"><link rel="prefetch" href="/assets/js/53.e6fd3dc2.js"><link rel="prefetch" href="/assets/js/54.e3991388.js"><link rel="prefetch" href="/assets/js/55.491b8d15.js"><link rel="prefetch" href="/assets/js/56.45ada881.js"><link rel="prefetch" href="/assets/js/57.92fbd908.js"><link rel="prefetch" href="/assets/js/58.08ac193c.js"><link rel="prefetch" href="/assets/js/59.7717fd50.js"><link rel="prefetch" href="/assets/js/6.b5995673.js"><link rel="prefetch" href="/assets/js/60.8ed1de3b.js"><link rel="prefetch" href="/assets/js/61.b12480ab.js"><link rel="prefetch" href="/assets/js/62.ad353c0f.js"><link rel="prefetch" href="/assets/js/63.ab51b80a.js"><link rel="prefetch" href="/assets/js/64.7e0eda3a.js"><link rel="prefetch" href="/assets/js/65.82f1f6c8.js"><link rel="prefetch" href="/assets/js/66.52934df3.js"><link rel="prefetch" href="/assets/js/67.e7eda742.js"><link rel="prefetch" href="/assets/js/68.0bbccf1e.js"><link rel="prefetch" href="/assets/js/69.b4cd09c5.js"><link rel="prefetch" href="/assets/js/7.57a25aa5.js"><link rel="prefetch" href="/assets/js/70.d05753e2.js"><link rel="prefetch" href="/assets/js/71.17961db2.js"><link rel="prefetch" href="/assets/js/72.c0ade5be.js"><link rel="prefetch" href="/assets/js/73.533d59cb.js"><link rel="prefetch" href="/assets/js/74.989bb737.js"><link rel="prefetch" href="/assets/js/75.8c28adbe.js"><link rel="prefetch" href="/assets/js/76.cbfd992c.js"><link rel="prefetch" href="/assets/js/77.cb1a4e31.js"><link rel="prefetch" href="/assets/js/78.5d14c420.js"><link rel="prefetch" href="/assets/js/79.b86ce7b4.js"><link rel="prefetch" href="/assets/js/8.0151b66b.js"><link rel="prefetch" href="/assets/js/80.e87d280d.js"><link rel="prefetch" href="/assets/js/81.be522b9f.js"><link rel="prefetch" href="/assets/js/82.dc2fc3e3.js"><link rel="prefetch" href="/assets/js/83.25e38715.js"><link rel="prefetch" href="/assets/js/84.500d1f16.js"><link rel="prefetch" href="/assets/js/85.5e2f5425.js"><link rel="prefetch" href="/assets/js/86.d1221f2f.js"><link rel="prefetch" href="/assets/js/87.8825f725.js"><link rel="prefetch" href="/assets/js/88.ec67c745.js"><link rel="prefetch" href="/assets/js/89.a3403b9c.js"><link rel="prefetch" href="/assets/js/9.cc5aac35.js"><link rel="prefetch" href="/assets/js/90.6fd5917a.js"><link rel="prefetch" href="/assets/js/91.790e4ae3.js"><link rel="prefetch" href="/assets/js/92.ce5cac72.js"><link rel="prefetch" href="/assets/js/93.b7acc201.js"><link rel="prefetch" href="/assets/js/94.3001f17b.js"><link rel="prefetch" href="/assets/js/95.8f55bc4f.js"><link rel="prefetch" href="/assets/js/96.9eaa4660.js"><link rel="prefetch" href="/assets/js/97.a2ada7d4.js"><link rel="prefetch" href="/assets/js/98.b694d4dd.js"><link rel="prefetch" href="/assets/js/99.6542bae0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ee4150ce.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/hope.jpg" alt="木易東" class="logo"> <span class="site-name can-hide">木易東</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  HOME
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  学习·笔记
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link">
  进阶·博文
</a></div><div class="nav-item"><a href="/code/" class="nav-link router-link-active">
  编程·语言
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法·练习
</a></div><div class="nav-item"><a href="/system/" class="nav-link">
  系统·设计
</a></div><div class="nav-item"><a href="/year/after/year/" class="nav-link">
  一年·一技
</a></div><div class="nav-item"><a href="https://github.com/muyids" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GITHUB
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  HOME
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  学习·笔记
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link">
  进阶·博文
</a></div><div class="nav-item"><a href="/code/" class="nav-link router-link-active">
  编程·语言
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法·练习
</a></div><div class="nav-item"><a href="/system/" class="nav-link">
  系统·设计
</a></div><div class="nav-item"><a href="/year/after/year/" class="nav-link">
  一年·一技
</a></div><div class="nav-item"><a href="https://github.com/muyids" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GITHUB
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Javascript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/code/js/1.变量和类型.html" class="sidebar-link">变量和类型</a></li><li><a href="/code/js/2.面向对象.html" class="sidebar-link">面向对象</a></li><li><a href="/code/js/3.作用域和闭包.html" class="sidebar-link">作用域和闭包</a></li><li><a href="/code/js/4.nodejs.html" aria-current="page" class="active sidebar-link">Node.js</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#为什么用node-js" class="sidebar-link">为什么用Node.js</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#事件循环和非阻塞io" class="sidebar-link">事件循环和非阻塞IO</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#单线程" class="sidebar-link">单线程</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#事件循环机制" class="sidebar-link">事件循环机制</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#异步事件" class="sidebar-link">异步事件</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#宏任务和微任务" class="sidebar-link">宏任务和微任务</a></li></ul></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#node的构架" class="sidebar-link">node的构架</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#node核心内置库及实现原理" class="sidebar-link">node核心内置库及实现原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#global" class="sidebar-link">global</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#定时器timer" class="sidebar-link">定时器Timer</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#进程管理" class="sidebar-link">进程管理</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#eventemitter" class="sidebar-link">EventEmitter</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#stream" class="sidebar-link">Stream</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#文件系统fs" class="sidebar-link">文件系统fs</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#网络" class="sidebar-link">网络</a></li></ul></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#优雅退出" class="sidebar-link">优雅退出</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#错误优先的回调函数" class="sidebar-link">错误优先的回调函数</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#如何避免回调地狱" class="sidebar-link">如何避免回调地狱</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#什么是stub" class="sidebar-link">什么是stub</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#express的路由机制" class="sidebar-link">express的路由机制</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#express和koa的区别" class="sidebar-link">Express和Koa的区别</a></li><li class="sidebar-sub-header"><a href="/code/js/4.nodejs.html#egg-js和nest-js" class="sidebar-link">egg.js和nest.js</a></li></ul></li><li><a href="/code/js/5.es6.html" class="sidebar-link">ES6</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Java</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/code/java/1.Map家族.html" class="sidebar-link">Map</a></li><li><a href="/code/java/2.collection.html" class="sidebar-link">Collection</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Golang</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/code/golang/go-base.html" class="sidebar-link">Golang基础</a></li><li><a href="/code/golang/go-interface.html" class="sidebar-link">接口</a></li><li><a href="/code/golang/go-concurrency.html" class="sidebar-link">Go并发编程</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="为什么用node-js"><a href="#为什么用node-js" class="header-anchor">#</a> 为什么用Node.js</h2> <ul><li>简单强大，轻量可扩展</li> <li>javascript,json来进行编码,web开发必备技能</li> <li>非阻塞IO,可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问</li> <li>前后端使用统一语言</li> <li>可扩展体现在可以轻松应对<strong>多实例，多服务器架构</strong>，同时有海量的第三方应用组件</li></ul> <h2 id="事件循环和非阻塞io"><a href="#事件循环和非阻塞io" class="header-anchor">#</a> 事件循环和非阻塞IO</h2> <h3 id="单线程"><a href="#单线程" class="header-anchor">#</a> 单线程</h3> <ul><li>传统web服务中，大多都是使用多线程机制来解决并发的问题，原因是I/O事件会阻塞线程，而阻塞就意味着要等待</li> <li>node的设计是采用了单线程的机制，只是针对 主线程来说，即每个node进程只有一个主线程来执行程序代码</li> <li>采用了<strong>事件驱动</strong>的机制，将耗时阻塞的I/O操作交给线程池中的某个线程去完成</li> <li>主线程本身只负责不断地调度，并没有执行真正的I/O操作。也就是说node实现的是异步非阻塞式。</li></ul> <p>底层，Node.js借助libuv来作为抽象封装层，从而屏蔽不同操作系统的差异</p> <p>libuv: linux下用libev实现，Windows下用IOCP实现</p> <p><strong>IO多路复用模型</strong></p> <h3 id="事件循环机制"><a href="#事件循环机制" class="header-anchor">#</a> 事件循环机制</h3> <p>根据node的官方介绍，node每次事件循环机制都包含了6个阶段：</p> <ul><li><strong>timers阶段</strong>：这个阶段执行已经到期的timer(setTimeout、setInterval)回调</li> <li><strong>I/O callbacks阶段</strong>：执行I/O（例如文件、网络）的回调</li> <li>idle, prepare 阶段：node内部使用</li> <li>poll阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</li> <li><strong>check阶段</strong>：执行setImmediate回调</li> <li>close callbacks阶段：执行close事件回调，比如TCP断开连接</li></ul> <p>对于日常开发来说，我们比较关注的是<code>timers、I/O callbacks、check阶段</code></p> <ul><li>node和浏览器相比一个明显的不同就是node在<strong>每个阶段结束后会去执行所有 process.nextTick 、microtask（promise）任务</strong></li></ul> <p>事件循环原理</p> <ul><li>node 的初始化
<ul><li>初始化 node 环境。</li> <li>执行输入代码。</li> <li>执行 process.nextTick 回调。</li> <li>执行 microtasks。</li></ul></li> <li>进入 event-loop
<ul><li>进入 timers 阶段
<ul><li>检查 timer 队列是否有到期的 timer 回调，如果有，将到期的 timer 回调按照 timerId 升序执行。</li> <li>检查是否有 process.nextTick 任务，如果有，全部执行。</li> <li>检查是否有microtask，如果有，全部执行。</li> <li>退出该阶段。</li></ul></li> <li>进入IO callbacks阶段
<ul><li>检查是否有 pending 的 I/O 回调。如果有，执行回调。如果没有，退出该阶段</li> <li>检查是否有 process.nextTick 任务，如果有，全部执行</li> <li>检查是否有microtask，如果有，全部执行</li> <li>退出该阶段</li></ul></li> <li>进入 idle，prepare 阶段：
<ul><li>这两个阶段与我们编程关系不大，暂且按下不表。</li></ul></li> <li>进入 poll 阶段</li> <li>进入 check 阶段</li> <li>进入 closing 阶段</li> <li>检查是否有活跃的 handles（定时器、IO等事件句柄）
<ul><li>如果有，继续下一轮循环。</li> <li>如果没有，结束事件循环，退出程序。</li></ul></li></ul></li></ul> <p>可以发现，在事件循环的每一个子阶段<strong>退出之前</strong>都会按顺序执行如下过程：</p> <ul><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li> <li>检查是否有 <code>microtasks</code>，如果有，全部执行</li> <li>退出当前阶段</li></ul> <p><strong>同一次事件循环中，微任务永远在宏任务之前执行</strong></p> <h3 id="异步事件"><a href="#异步事件" class="header-anchor">#</a> 异步事件</h3> <p>非I/O：</p> <ul><li>定时器（setTimeout，setInterval）</li> <li>process.nextTick</li> <li>microtask（promise）</li> <li>setImmediate</li> <li>DNS.lookup</li></ul> <p>I/O：</p> <ul><li>网络I/O</li> <li>文件I/O</li> <li>一些DNS操作</li></ul> <h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="header-anchor">#</a> 宏任务和微任务</h3> <p>任务队列又分为<code>macro-task（宏任务）</code>与<code>micro-task（微任务）</code>，在最新标准中，它们被分别称为<code>task</code>与<code>jobs</code></p> <p>当前执行栈执行完毕时会立刻先处理所有<strong>微任务队列</strong>中的事件，然后再去<strong>宏任务队列</strong>中取出一个事件。<strong>同一次事件循环中，微任务永远在宏任务之前执行</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">_</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>输出： 1，2，3，4</p> <ol><li>new Promise =&gt; 同步执行</li> <li>Promise.then() =&gt; Promise.then()中注册的回调才是异步执行的；具有代表性的微任务</li> <li>setTimeout就是作为宏任务来存在的</li></ol> <ul><li>微任务：process.nextTick、Promise.then catch finally</li> <li>宏任务： I/O，setTimeout、setInterval、setImmediate,script(整体代码),UI rendering</li></ul> <h2 id="node的构架"><a href="#node的构架" class="header-anchor">#</a> node的构架</h2> <p>主要分为三层: <strong>应用app &gt;&gt; V8及node内置架构 &gt;&gt; 操作系统</strong></p> <p>V8是node运行的环境，可以理解为node虚拟机．</p> <p>node内置架构又可分为三层: <strong>核心模块(javascript实现) &gt;&gt; c++绑定 &gt;&gt; libuv + CAes + http</strong></p> <p><img src="https://muyids.oss-cn-beijing.aliyuncs.com/node-framwork.png" alt="node的构架"></p> <h2 id="node核心内置库及实现原理"><a href="#node核心内置库及实现原理" class="header-anchor">#</a> node核心内置库及实现原理</h2> <p>常用的核心内置库如<code>事件EventEmitter</code>，<code>流Stream</code>，<code>文件fs</code>，<code>网络net,http,https</code>，<code>进程管理process、cluster</code>等</p> <h3 id="global"><a href="#global" class="header-anchor">#</a> global</h3> <p>全局对象包括：模块变量函数，Buffer类，Timer函数，process, console</p> <h4 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h4> <ol><li>__dirname</li> <li>__filename</li> <li>exports</li> <li>module</li> <li>require()</li></ol> <h3 id="定时器timer"><a href="#定时器timer" class="header-anchor">#</a> 定时器Timer</h3> <p>js中有哪些定时器？</p> <blockquote><p>setTimeout/clearTimeout, setInterval/clearInterval, setImmediate/clearImmediate</p></blockquote> <p>任务执行顺序： 同步 &gt; process.nextTick() &gt; Promise &gt; setTimeout(,less time) &gt; setImmediate &gt;  setTimeout(,more time)</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// test.js</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4. 而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5. 而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2. process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3. process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1. 同步任务总是比异步任务更早执行。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>运行结果如下</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token number">5</span> 
<span class="token number">3</span>
<span class="token number">4</span>
<span class="token number">1</span>
<span class="token number">2</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>setTimeout和setImmediate，如果setTimeout的时间足够小，则setTimeout先执行，如果为什么？</strong></p> <ol><li>查看 Timer源码，setImmediate 和 setTimeout最终都是在一个 时间堆<code>PriorityQueue</code> 上进行执行</li> <li>但是，一开始setImmediates先加入队列immediateQueue使用双端链表linkedlist实现</li> <li>执行的时候，setImmediates从队列进入 时间堆<code>PriorityQueue</code>，这个过程是有代价的，所有如果 setTimeout是0ms或者说时间足够小，setTimeout先执行</li></ol> <h3 id="进程管理"><a href="#进程管理" class="header-anchor">#</a> 进程管理</h3> <p>child_process, cluster</p> <h4 id="child-process创建子进程的方式"><a href="#child-process创建子进程的方式" class="header-anchor">#</a> child_process创建子进程的方式</h4> <ul><li>.exec()、.execFile()、.fork()底层都是通过<code>.spawn()</code>实现的。</li> <li>.exec()、execFile()额外提供了回调，当子进程停止的时候执行</li></ul> <p><strong>风险项</strong></p> <p>传入的命令，如果是用户输入的，有可能产生<strong>类似sql注入的风险</strong>，比如</p> <p><code>exec('ls hello.txt', function(error, stdout, stderr){})</code>
恶意攻击 =&gt;
<code>exec('ls hello.txt; rm -rf *', function(error, stdout, stderr){})</code></p> <h4 id="cluster"><a href="#cluster" class="header-anchor">#</a> cluster</h4> <p>master 进程通过 <code>process.fork()</code> 创建子进程，他们之间通过 <code>IPC (内部进程通信)</code>通道实现通信。</p> <p>操作系统的进程间通信方式: 共享内存，消息传递（socket,rpc），信号量，管道,消息队列等</p> <ol><li>共享内存；不同进程共享同一段内存空间。通常还需要引入信号量机制，来实现同步与互斥。</li> <li>消息传递；这种模式下，进程间通过发送、接收消息来实现信息的同步。nodejs父子进程通过事件机制通信，就是这种模型</li> <li>信号量；信号量简单说就是系统赋予进程的一个状态值，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量只有 0 或者 1 两个值的话，又被称作“互斥锁”。这个机制也被广泛用于各种编程模式中。</li> <li>管道；用于连接两个进程，将一个进程的输出作为另一个进程的输入</li></ol> <p>Node.js 为父子进程的通信提供了<strong>事件机制EventEmmiter</strong>来传递消息。</p> <h5 id="负载均衡策略"><a href="#负载均衡策略" class="header-anchor">#</a> 负载均衡策略</h5> <p>Node.js 默认采用的策略是 round-robin 时间片轮转法。</p> <p>负载均衡算法:</p> <ul><li>round-robin <strong>时间片轮转法</strong>; 每一次把来自用户的请求轮流分配给各个进程，不足：处理效率不一样，会出现负载不均衡</li> <li>WRR (weight-round-robin) <strong>加权轮转法</strong>；</li></ul> <p>时间片轮转法（round-robin）<strong>不适用于windows</strong>, 第二种方式是由主进程创建 socket 监听端口后, 将 <strong>socket 句柄直接分发</strong>给相应的 worker, 然后当连接进来时, 就直接由相应的 worker 来接收连接并处理；存在负载不均衡的问题, 比如通常 70% 的连接仅被 8 个进程中的 2 个处理, 而其他进程比较清闲.</p> <h5 id="多进程的端口监听"><a href="#多进程的端口监听" class="header-anchor">#</a> 多进程的端口监听</h5> <ol><li>master 进程负责监听端口</li> <li>然后将连接通过某种分发策略（比如 round-robin），转发给 worker 进程。</li> <li>这样由于只有 master 进程接收客户端连接，就解决了竞争导致的负载不均衡的问题</li> <li>关键：要求 master 进程的稳定性足够好</li></ol> <h3 id="eventemitter"><a href="#eventemitter" class="header-anchor">#</a> EventEmitter</h3> <p>EventEmitter是node中一个实现<strong>观察者模式</strong>的类，主要功能是<strong>监听和发射消息，用于处理多模块交互问题</strong></p> <h4 id="代码实现"><a href="#代码实现" class="header-anchor">#</a> 代码实现</h4> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'events'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>EventEmitter<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">EventEmitter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// 构造函数</span>

util<span class="token punctuation">.</span><span class="token function">inherits</span><span class="token punctuation">(</span>MyEmitter<span class="token punctuation">,</span> EventEmitter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继承</span>

<span class="token keyword">var</span> em <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
em<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'收到事件hello的数据:'</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接收事件，并打印到控制台</span>
em<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token string">'EventEmitter传递消息真方便!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="eventemitter有哪些典型应用"><a href="#eventemitter有哪些典型应用" class="header-anchor">#</a> EventEmitter有哪些典型应用</h4> <ol><li><strong>模块间传递消息</strong></li> <li><strong>回调函数内外传递消息</strong></li> <li>处理<strong>流数据</strong>，因为流是在EventEmitter基础上实现的.</li> <li><strong>观察者模式发射触发机制</strong>相关应用</li></ol> <h4 id="怎么捕获eventemitter的错误事件"><a href="#怎么捕获eventemitter的错误事件" class="header-anchor">#</a> 怎么捕获EventEmitter的错误事件</h4> <p><strong>监听error事件</strong>即可．如果有多个EventEmitter,也可以用<strong>domain来统一处理错误事件</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> domain <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'domain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myDomain <span class="token operator">=</span> domain<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
myDomain<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'domain接收到的错误事件:'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接收事件并打印</span>
myDomain<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> emitter1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    emitter1<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token string">'错误事件来自emitter1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    emitter2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    emitter2<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token string">'错误事件来自emitter2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="eventemitter中的newlistenser事件有什么用处"><a href="#eventemitter中的newlistenser事件有什么用处" class="header-anchor">#</a> EventEmitter中的newListenser事件有什么用处</h4> <p><code>newListener</code>可以用来做事件机制的反射，特殊应用，事件管理等</p> <p><strong>当任何on事件添加到EventEmitter时，就会触发newListener事件</strong>，基于这种模式，我们可以做很多自定义处理.</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> emitter3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
emitter3<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'newListener'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> listener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;新事件的名字:&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;新事件的代码:&quot;</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;我是自定义延时处理机制&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
emitter3<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello　node'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="stream"><a href="#stream" class="header-anchor">#</a> Stream</h3> <p>stream是基于事件<code>EventEmitter</code>的数据管理模式．由各种不同的抽象接口组成，主要包括<code>可写，可读，可读写，可转换等</code>几种类型</p> <h4 id="stream有什么好处"><a href="#stream有什么好处" class="header-anchor">#</a> Stream有什么好处</h4> <p><code>非阻塞式数据处理</code>提升效率，片断处理节省内存，<code>管道处理</code>方便可扩展等</p> <h4 id="stream有哪些典型应用"><a href="#stream有哪些典型应用" class="header-anchor">#</a> Stream有哪些典型应用</h4> <p>文件，网络，数据转换，音频视频等</p> <h4 id="怎么捕获stream的错误事件"><a href="#怎么捕获stream的错误事件" class="header-anchor">#</a> 怎么捕获Stream的错误事件</h4> <p>监听<code>error</code>事件，方法同EventEmitter</p> <h4 id="有哪些常用stream-分别什么时候使用"><a href="#有哪些常用stream-分别什么时候使用" class="header-anchor">#</a> 有哪些常用Stream,分别什么时候使用</h4> <ul><li>可读流<code>Readable</code>，在作为输入数据源时使用；</li> <li>可写流<code>Writable</code>,在作为输出源时使用；</li> <li>双工流<code>Duplex</code>,它作为输出源接受被写入，同时又作为输入源被后面的流读出．</li> <li>转换流<code>Transform</code>，跟<code>Duplex</code>一样，都是双向流，但它的输出与输入是相关联的
<ul><li>需要实现一个函数<code>_transfrom(chunk, encoding, callback)</code>;而Duplex需要分别实现<code>_read(size)</code>函数和<code>_write(chunk, encoding, callback)</code>函数</li></ul></li></ul> <h4 id="缓冲"><a href="#缓冲" class="header-anchor">#</a> 缓冲</h4> <p>highWaterMark</p> <p>可缓冲的数据大小取决于传入流构造函数的 highWaterMark 选项。 对于普通的流， highWaterMark 指定了字节的总数。 对于对象模式的流， highWaterMark 指定了对象的总数。</p> <p>限制数据的缓冲到可接受的程度，也就是<strong>读写速度不一致的源头与目的地不会压垮内存</strong></p> <h4 id="实现一个writable-stream"><a href="#实现一个writable-stream" class="header-anchor">#</a> 实现一个Writable Stream</h4> <p>三步走:</p> <ol><li>继承<code>Writable</code></li> <li>覆写原型链方法<code>_write(chunk, encoding, callback)</code>函数</li></ol> <p>代码实现：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> Writable <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'stream'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Writable<span class="token punctuation">;</span>
<span class="token keyword">var</span> util <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'util'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyWritable</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">Writable</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构造继承</span>
<span class="token punctuation">}</span> 
util<span class="token punctuation">.</span><span class="token function">inherits</span><span class="token punctuation">(</span>MyWritable<span class="token punctuation">,</span> Writable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 继承Writable</span>
<span class="token class-name">MyWritable</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_write</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;被写入的数据是:&quot;</span><span class="token punctuation">,</span> chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此处可对写入的数据进行处理</span>
	<span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// stdin作为输入源，MyWritable作为输出源   </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="文件系统fs"><a href="#文件系统fs" class="header-anchor">#</a> 文件系统fs</h3> <p>Node通过fs模块来和<strong>文件系统</strong>进行交互，该模块提供了一些<strong>标准的文件访问API类</strong>打开、读取、写入文件、以及与其交互。</p> <h4 id="内置的fs模块架构是什么样子的"><a href="#内置的fs模块架构是什么样子的" class="header-anchor">#</a> 内置的fs模块架构是什么样子的</h4> <p>fs模块主要由下面几部分组成:</p> <ol><li><strong>POSIX文件操作的封装</strong>,对应于<strong>操作系统的原生文件操作</strong>; unlink,stat,rename...</li> <li>文件流 fs.createReadStream和fs.createWriteStream</li> <li>同步文件读写, fs.readFileSync和fs.writeFileSync</li> <li>异步文件读写, fs.readFile和fs.writeFile</li></ol> <h4 id="读写一个文件有多少种方法"><a href="#读写一个文件有多少种方法" class="header-anchor">#</a> 读写一个文件有多少种方法</h4> <p>总体来说有四种:</p> <ol><li>POSIX式底层读写</li> <li>流式读写</li> <li>同步读写</li> <li>异步读写</li></ol> <h4 id="怎么读取json配置文件"><a href="#怎么读取json配置文件" class="header-anchor">#</a> 怎么读取json配置文件</h4> <ol><li>利用node内置的<code>require('data.json')</code>机制 (<strong>注意</strong>：其中一个改变了js对象，其它跟着改变)</li> <li>读入文件入内容，然后用<code>JSON.parse(content)</code>转换成js对象</li></ol> <p>两种方式的区别：</p> <ol><li>require机制情况下，如果多个模块都加载了同一个json文件，那么其中一个改变了js对象，其它跟着改变，这是由node模块的<strong>缓存机制</strong>造成的，只有一个js模块对象</li> <li>第二种方式则可以随意改变加载后的js变量，而且各模块互不影响，因为他们都是独立的，是多个js对象</li></ol> <h4 id="fs-watch和fs-watchfile有什么区别"><a href="#fs-watch和fs-watchfile有什么区别" class="header-anchor">#</a> fs.watch和fs.watchFile有什么区别</h4> <p>二者主要用来监听文件变动</p> <ol><li>fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统;</li> <li>fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</li></ol> <h3 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h3> <h4 id="node的网络模块架构是什么样子的"><a href="#node的网络模块架构是什么样子的" class="header-anchor">#</a> node的网络模块架构是什么样子的</h4> <p>node全面支持各种网络服务器和客户端，包括<code>http/https, tcp, udp, dns, tls/ssl</code>等</p> <h4 id="node是怎样支持https-tls的"><a href="#node是怎样支持https-tls的" class="header-anchor">#</a> node是怎样支持https,tls的</h4> <p>要实现以下几个步骤即可:</p> <ol><li><code>openssl</code>生成公钥私钥</li> <li>服务器或客户端使用<code>https</code>替代http</li> <li>服务器或客户端加载公钥私钥证书</li></ol> <h2 id="优雅退出"><a href="#优雅退出" class="header-anchor">#</a> 优雅退出</h2> <p><code>graceful</code>模块配合<code>cluster</code>就可以实现这个解决方案。</p> <p>graceful是基于domain模块实现的</p> <p>domain；能捕捉异步回调中出现的异常。（弥补try...catch...的不足）</p> <p>process.on('uncaughtException)</p> <h2 id="错误优先的回调函数"><a href="#错误优先的回调函数" class="header-anchor">#</a> 错误优先的回调函数</h2> <p>错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象， 用于检查程序是否发生了错误。其余的参数用于传递数据。</p> <p>只有遵循错误优先回调的函数可以promisify</p> <h2 id="如何避免回调地狱"><a href="#如何避免回调地狱" class="header-anchor">#</a> 如何避免回调地狱</h2> <ul><li>使用三方库，Q, blubird, async进行promisify</li> <li>使用Promise链式调用</li> <li>使用yield+生成器generator或Promise, co</li> <li>使用async, await语法糖ES6</li></ul> <h2 id="什么是stub"><a href="#什么是stub" class="header-anchor">#</a> 什么是stub</h2> <p><code>TDD、Stub和Mock</code></p> <p><code>stub</code>存在的意图是为了让测试对象可以正常的执行，硬编码一些输入和输出</p> <p><code>mock</code>除了保证stub的功能之外，还可深入的模拟对象之间的交互方式，如：调用了几次、在某种情况下是否会抛出异常</p> <p>stub是 mock 的子集</p> <h2 id="express的路由机制"><a href="#express的路由机制" class="header-anchor">#</a> express的路由机制</h2> <p>express是如何从一个中间件执行到下一个中间件的?</p> <p>A: <code>app.use()</code></p> <p>app.use()的原理是什么？</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">middleware</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 做该干的事</span>

    <span class="token comment">// 做完后调用下一个函数</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// next也是一个函数，它表示函数数组中的下一个函数</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>其实所有中间件函数，是顺序添加到<strong>中间件数组</strong>里面，这个函数数组表示在发出响应之前要执行的所有函数</p> <p>使用app.use(fn)后，传进来的fn就会被扔到这个数组里，执行完毕后调用next()方法执行函数数组里的下一个函数，如果没有调用next()的话，就不会调用下一个函数了，也就是说调用就会被终止</p> <h2 id="express和koa的区别"><a href="#express和koa的区别" class="header-anchor">#</a> Express和Koa的区别</h2> <ol><li>Handler 处理方式
<ul><li>Express 使用普通的回调函数，一种线性的逻辑，在同一个线程上完成所有的 HTTP 请求;异步操作的执行顺序不确定；回调的方式不利于错误捕获；</li> <li>使用ES7的<strong>Async/Await</strong>替换了原来的 Generator + co 的模式; Async/Await 现在也称为 JS 异步的终极解决方案。</li></ul></li> <li>中间件实现机制
<ul><li>koa2: 中间件 Compose;洋葱圈模型;会去等待异步（Promise）完成;可以非常方便的<strong>实现后置处理逻辑</strong></li> <li>Express 中间件实现是基于 Callback 回调函数同步的，它<strong>不会去等待异步（Promise）完成</strong></li></ul></li> <li>响应机制
<ul><li>在 Koa 中数据的响应是通过 ctx.body 进行设置，注意这里仅是设置并没有立即响应，而是在所有的中间件结束之后做了响应;这样做一个好处是我们在响应之前是有一些预留操作空间的，</li> <li>express:res.send() 之后就立即响应了，这样如果还想在上层中间件做一些操作是有点难的。</li></ul></li></ol> <p>其实，Express 也是类似的洋葱模型，不同的是：</p> <p>Express 中间件机制使用了 Callback 实现，这样如果出现异步则可能会使你在执行顺序上感到困惑，因此如果我们想做接口耗时统计、错误处理 Koa 的这种中间件模式处理起来更方便些。最后一点响应机制也很重要，Koa 不是立即响应，是整个中间件处理完成在最外层进行了响应，而 Express 则是立即响应。</p> <h2 id="egg-js和nest-js"><a href="#egg-js和nest-js" class="header-anchor">#</a> egg.js和nest.js</h2> <ul><li>egg.js是在koa的基础上做了一层很好的面向大型企业级应用的框架封装</li> <li>egg支持ts</li> <li>egg.js更多的是按照<strong>洋葱模型</strong>的开发方式，和AOP编程还是有点区别的</li> <li>NEST.js配合typeorm可以在node下拥有不输Spring的<strong>面向切面编程</strong>的体验</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/code/js/3.作用域和闭包.html" class="prev">
        作用域和闭包
      </a></span> <span class="next"><a href="/code/js/5.es6.html">
        ES6
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4ab909ce.js" defer></script><script src="/assets/js/2.268f4e54.js" defer></script><script src="/assets/js/133.17e53083.js" defer></script>
  </body>
</html>
