<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机网络知识点总结 | 木易東</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link,[object Object] 0="meta" 1="[object Object]"></link,[object Object]>
    <meta name="description" content="路漫漫其修远兮，吾将上下而求索">
    <link rel="preload" href="/assets/css/0.styles.ee4150ce.css" as="style"><link rel="preload" href="/assets/js/app.4ab909ce.js" as="script"><link rel="preload" href="/assets/js/2.268f4e54.js" as="script"><link rel="preload" href="/assets/js/110.e88d5e3b.js" as="script"><link rel="prefetch" href="/assets/js/10.209d185b.js"><link rel="prefetch" href="/assets/js/100.ed3b3fa7.js"><link rel="prefetch" href="/assets/js/101.0bc6f23b.js"><link rel="prefetch" href="/assets/js/102.266baf3f.js"><link rel="prefetch" href="/assets/js/103.41770349.js"><link rel="prefetch" href="/assets/js/104.d6b11437.js"><link rel="prefetch" href="/assets/js/105.12842ff7.js"><link rel="prefetch" href="/assets/js/106.ff323f9e.js"><link rel="prefetch" href="/assets/js/107.275a0c10.js"><link rel="prefetch" href="/assets/js/108.5b919ed5.js"><link rel="prefetch" href="/assets/js/109.332c56e1.js"><link rel="prefetch" href="/assets/js/11.f3d69358.js"><link rel="prefetch" href="/assets/js/111.098714a4.js"><link rel="prefetch" href="/assets/js/112.fc7ba3e2.js"><link rel="prefetch" href="/assets/js/113.a08c2b6f.js"><link rel="prefetch" href="/assets/js/114.c4d0f581.js"><link rel="prefetch" href="/assets/js/115.317cb7ca.js"><link rel="prefetch" href="/assets/js/116.97e580b5.js"><link rel="prefetch" href="/assets/js/117.121ea3ac.js"><link rel="prefetch" href="/assets/js/118.a0665182.js"><link rel="prefetch" href="/assets/js/119.7325dcf0.js"><link rel="prefetch" href="/assets/js/12.df591af5.js"><link rel="prefetch" href="/assets/js/120.326b52e9.js"><link rel="prefetch" href="/assets/js/121.f8bc07cd.js"><link rel="prefetch" href="/assets/js/122.3cb1ec13.js"><link rel="prefetch" href="/assets/js/123.ab44e19c.js"><link rel="prefetch" href="/assets/js/124.ef229142.js"><link rel="prefetch" href="/assets/js/125.c7c6e12d.js"><link rel="prefetch" href="/assets/js/126.442fa3e6.js"><link rel="prefetch" href="/assets/js/127.b36113ef.js"><link rel="prefetch" href="/assets/js/128.a489ffc0.js"><link rel="prefetch" href="/assets/js/129.ed5adff8.js"><link rel="prefetch" href="/assets/js/13.9ab5db74.js"><link rel="prefetch" href="/assets/js/130.41c2a9b4.js"><link rel="prefetch" href="/assets/js/131.1ea71563.js"><link rel="prefetch" href="/assets/js/132.0f926da5.js"><link rel="prefetch" href="/assets/js/133.17e53083.js"><link rel="prefetch" href="/assets/js/134.382858c4.js"><link rel="prefetch" href="/assets/js/135.03feac86.js"><link rel="prefetch" href="/assets/js/136.60959adc.js"><link rel="prefetch" href="/assets/js/137.cc05055e.js"><link rel="prefetch" href="/assets/js/138.6e37fdbd.js"><link rel="prefetch" href="/assets/js/139.53f853a7.js"><link rel="prefetch" href="/assets/js/14.d8bf8180.js"><link rel="prefetch" href="/assets/js/140.c87f4519.js"><link rel="prefetch" href="/assets/js/141.2284d2b3.js"><link rel="prefetch" href="/assets/js/142.55320a45.js"><link rel="prefetch" href="/assets/js/143.fdfacb09.js"><link rel="prefetch" href="/assets/js/144.152e977e.js"><link rel="prefetch" href="/assets/js/145.0498b272.js"><link rel="prefetch" href="/assets/js/146.dd4b2b24.js"><link rel="prefetch" href="/assets/js/147.c2b141cf.js"><link rel="prefetch" href="/assets/js/148.edf0d726.js"><link rel="prefetch" href="/assets/js/149.72f09253.js"><link rel="prefetch" href="/assets/js/15.386b2793.js"><link rel="prefetch" href="/assets/js/150.39b686e7.js"><link rel="prefetch" href="/assets/js/151.6ddc4eba.js"><link rel="prefetch" href="/assets/js/152.47d4d5d0.js"><link rel="prefetch" href="/assets/js/153.93edd93b.js"><link rel="prefetch" href="/assets/js/154.ed8a1efe.js"><link rel="prefetch" href="/assets/js/155.84069324.js"><link rel="prefetch" href="/assets/js/156.0981fa5b.js"><link rel="prefetch" href="/assets/js/157.b4b037d6.js"><link rel="prefetch" href="/assets/js/158.de7f19e2.js"><link rel="prefetch" href="/assets/js/159.5552f303.js"><link rel="prefetch" href="/assets/js/16.16143f64.js"><link rel="prefetch" href="/assets/js/160.aac84d1a.js"><link rel="prefetch" href="/assets/js/161.57acc46e.js"><link rel="prefetch" href="/assets/js/162.17be9e3e.js"><link rel="prefetch" href="/assets/js/163.7d0b5f23.js"><link rel="prefetch" href="/assets/js/164.0090922d.js"><link rel="prefetch" href="/assets/js/165.ef7c2a2e.js"><link rel="prefetch" href="/assets/js/166.5a56227f.js"><link rel="prefetch" href="/assets/js/167.0695d6d5.js"><link rel="prefetch" href="/assets/js/168.e718301b.js"><link rel="prefetch" href="/assets/js/169.0dfae1c1.js"><link rel="prefetch" href="/assets/js/17.560a3e0a.js"><link rel="prefetch" href="/assets/js/170.2c0cdfce.js"><link rel="prefetch" href="/assets/js/171.290835f2.js"><link rel="prefetch" href="/assets/js/172.6e354475.js"><link rel="prefetch" href="/assets/js/173.35718045.js"><link rel="prefetch" href="/assets/js/174.55e350a8.js"><link rel="prefetch" href="/assets/js/175.7fe8e56c.js"><link rel="prefetch" href="/assets/js/176.5bf41792.js"><link rel="prefetch" href="/assets/js/177.51b9503f.js"><link rel="prefetch" href="/assets/js/178.7f4c1269.js"><link rel="prefetch" href="/assets/js/179.7bb26f94.js"><link rel="prefetch" href="/assets/js/18.6c788be1.js"><link rel="prefetch" href="/assets/js/180.c6f48737.js"><link rel="prefetch" href="/assets/js/181.6f40d208.js"><link rel="prefetch" href="/assets/js/182.cc8d6d4a.js"><link rel="prefetch" href="/assets/js/183.17deaed8.js"><link rel="prefetch" href="/assets/js/184.483c498a.js"><link rel="prefetch" href="/assets/js/185.f175ff65.js"><link rel="prefetch" href="/assets/js/186.9af453a8.js"><link rel="prefetch" href="/assets/js/187.bede2d0f.js"><link rel="prefetch" href="/assets/js/188.323ce242.js"><link rel="prefetch" href="/assets/js/189.1a925619.js"><link rel="prefetch" href="/assets/js/19.b2e312a4.js"><link rel="prefetch" href="/assets/js/190.4d691d6a.js"><link rel="prefetch" href="/assets/js/191.5a781b2d.js"><link rel="prefetch" href="/assets/js/192.1ffd0916.js"><link rel="prefetch" href="/assets/js/193.7ec310d1.js"><link rel="prefetch" href="/assets/js/194.d47c85ca.js"><link rel="prefetch" href="/assets/js/195.84c82c66.js"><link rel="prefetch" href="/assets/js/196.c77dc4ad.js"><link rel="prefetch" href="/assets/js/197.8a07281c.js"><link rel="prefetch" href="/assets/js/198.86f529c1.js"><link rel="prefetch" href="/assets/js/199.15e8d4c3.js"><link rel="prefetch" href="/assets/js/20.4d25735a.js"><link rel="prefetch" href="/assets/js/200.b3c8df9d.js"><link rel="prefetch" href="/assets/js/201.d83e7de9.js"><link rel="prefetch" href="/assets/js/202.05586c6f.js"><link rel="prefetch" href="/assets/js/203.2ea42e2f.js"><link rel="prefetch" href="/assets/js/204.41b1e1cb.js"><link rel="prefetch" href="/assets/js/205.cd69877a.js"><link rel="prefetch" href="/assets/js/206.be348d56.js"><link rel="prefetch" href="/assets/js/207.b9e8002f.js"><link rel="prefetch" href="/assets/js/208.962350ff.js"><link rel="prefetch" href="/assets/js/209.4fd61d0c.js"><link rel="prefetch" href="/assets/js/21.63d223ed.js"><link rel="prefetch" href="/assets/js/210.cc8c457c.js"><link rel="prefetch" href="/assets/js/211.d251ee9f.js"><link rel="prefetch" href="/assets/js/212.5007cefb.js"><link rel="prefetch" href="/assets/js/213.d33d9f03.js"><link rel="prefetch" href="/assets/js/214.503c33ec.js"><link rel="prefetch" href="/assets/js/215.df94bc76.js"><link rel="prefetch" href="/assets/js/216.163a50bd.js"><link rel="prefetch" href="/assets/js/217.21b20dbb.js"><link rel="prefetch" href="/assets/js/218.edf914d2.js"><link rel="prefetch" href="/assets/js/219.6b54dbc4.js"><link rel="prefetch" href="/assets/js/22.42386486.js"><link rel="prefetch" href="/assets/js/220.b344f421.js"><link rel="prefetch" href="/assets/js/221.d93c8092.js"><link rel="prefetch" href="/assets/js/222.8e918999.js"><link rel="prefetch" href="/assets/js/223.671a27bc.js"><link rel="prefetch" href="/assets/js/224.53c00cb7.js"><link rel="prefetch" href="/assets/js/225.615e5576.js"><link rel="prefetch" href="/assets/js/226.d7d4d768.js"><link rel="prefetch" href="/assets/js/227.8dafb796.js"><link rel="prefetch" href="/assets/js/228.7312b790.js"><link rel="prefetch" href="/assets/js/229.f5724c5b.js"><link rel="prefetch" href="/assets/js/23.ee235590.js"><link rel="prefetch" href="/assets/js/230.5be9199b.js"><link rel="prefetch" href="/assets/js/231.6b143716.js"><link rel="prefetch" href="/assets/js/24.51c34572.js"><link rel="prefetch" href="/assets/js/25.e697ec23.js"><link rel="prefetch" href="/assets/js/26.246009e9.js"><link rel="prefetch" href="/assets/js/27.d4c92ad1.js"><link rel="prefetch" href="/assets/js/28.2ba95f3c.js"><link rel="prefetch" href="/assets/js/29.9772506d.js"><link rel="prefetch" href="/assets/js/3.ff5569b2.js"><link rel="prefetch" href="/assets/js/30.dae831a7.js"><link rel="prefetch" href="/assets/js/31.9ac2092a.js"><link rel="prefetch" href="/assets/js/32.3c2776c5.js"><link rel="prefetch" href="/assets/js/33.95a0d7b7.js"><link rel="prefetch" href="/assets/js/34.a145664d.js"><link rel="prefetch" href="/assets/js/35.357ff9ec.js"><link rel="prefetch" href="/assets/js/36.1594f674.js"><link rel="prefetch" href="/assets/js/37.5045d89d.js"><link rel="prefetch" href="/assets/js/38.a87807f8.js"><link rel="prefetch" href="/assets/js/39.22360d3d.js"><link rel="prefetch" href="/assets/js/4.cab6e33f.js"><link rel="prefetch" href="/assets/js/40.ed8d7ea6.js"><link rel="prefetch" href="/assets/js/41.86dc2857.js"><link rel="prefetch" href="/assets/js/42.2719d1a7.js"><link rel="prefetch" href="/assets/js/43.1121877d.js"><link rel="prefetch" href="/assets/js/44.d2894bdb.js"><link rel="prefetch" href="/assets/js/45.a4f59145.js"><link rel="prefetch" href="/assets/js/46.e91142f2.js"><link rel="prefetch" href="/assets/js/47.6120f6e3.js"><link rel="prefetch" href="/assets/js/48.36593726.js"><link rel="prefetch" href="/assets/js/49.280a435b.js"><link rel="prefetch" href="/assets/js/5.db6eddb9.js"><link rel="prefetch" href="/assets/js/50.ac5aa141.js"><link rel="prefetch" href="/assets/js/51.ec413eaa.js"><link rel="prefetch" href="/assets/js/52.3b4de5ad.js"><link rel="prefetch" href="/assets/js/53.e6fd3dc2.js"><link rel="prefetch" href="/assets/js/54.e3991388.js"><link rel="prefetch" href="/assets/js/55.491b8d15.js"><link rel="prefetch" href="/assets/js/56.45ada881.js"><link rel="prefetch" href="/assets/js/57.92fbd908.js"><link rel="prefetch" href="/assets/js/58.08ac193c.js"><link rel="prefetch" href="/assets/js/59.7717fd50.js"><link rel="prefetch" href="/assets/js/6.b5995673.js"><link rel="prefetch" href="/assets/js/60.8ed1de3b.js"><link rel="prefetch" href="/assets/js/61.b12480ab.js"><link rel="prefetch" href="/assets/js/62.ad353c0f.js"><link rel="prefetch" href="/assets/js/63.ab51b80a.js"><link rel="prefetch" href="/assets/js/64.7e0eda3a.js"><link rel="prefetch" href="/assets/js/65.82f1f6c8.js"><link rel="prefetch" href="/assets/js/66.52934df3.js"><link rel="prefetch" href="/assets/js/67.e7eda742.js"><link rel="prefetch" href="/assets/js/68.0bbccf1e.js"><link rel="prefetch" href="/assets/js/69.b4cd09c5.js"><link rel="prefetch" href="/assets/js/7.57a25aa5.js"><link rel="prefetch" href="/assets/js/70.d05753e2.js"><link rel="prefetch" href="/assets/js/71.17961db2.js"><link rel="prefetch" href="/assets/js/72.c0ade5be.js"><link rel="prefetch" href="/assets/js/73.533d59cb.js"><link rel="prefetch" href="/assets/js/74.989bb737.js"><link rel="prefetch" href="/assets/js/75.8c28adbe.js"><link rel="prefetch" href="/assets/js/76.cbfd992c.js"><link rel="prefetch" href="/assets/js/77.cb1a4e31.js"><link rel="prefetch" href="/assets/js/78.5d14c420.js"><link rel="prefetch" href="/assets/js/79.b86ce7b4.js"><link rel="prefetch" href="/assets/js/8.0151b66b.js"><link rel="prefetch" href="/assets/js/80.e87d280d.js"><link rel="prefetch" href="/assets/js/81.be522b9f.js"><link rel="prefetch" href="/assets/js/82.dc2fc3e3.js"><link rel="prefetch" href="/assets/js/83.25e38715.js"><link rel="prefetch" href="/assets/js/84.500d1f16.js"><link rel="prefetch" href="/assets/js/85.5e2f5425.js"><link rel="prefetch" href="/assets/js/86.d1221f2f.js"><link rel="prefetch" href="/assets/js/87.8825f725.js"><link rel="prefetch" href="/assets/js/88.ec67c745.js"><link rel="prefetch" href="/assets/js/89.a3403b9c.js"><link rel="prefetch" href="/assets/js/9.cc5aac35.js"><link rel="prefetch" href="/assets/js/90.6fd5917a.js"><link rel="prefetch" href="/assets/js/91.790e4ae3.js"><link rel="prefetch" href="/assets/js/92.ce5cac72.js"><link rel="prefetch" href="/assets/js/93.b7acc201.js"><link rel="prefetch" href="/assets/js/94.3001f17b.js"><link rel="prefetch" href="/assets/js/95.8f55bc4f.js"><link rel="prefetch" href="/assets/js/96.9eaa4660.js"><link rel="prefetch" href="/assets/js/97.a2ada7d4.js"><link rel="prefetch" href="/assets/js/98.b694d4dd.js"><link rel="prefetch" href="/assets/js/99.6542bae0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ee4150ce.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/hope.jpg" alt="木易東" class="logo"> <span class="site-name can-hide">木易東</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  HOME
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  学习·笔记
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link router-link-active">
  进阶·博文
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  编程·语言
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法·练习
</a></div><div class="nav-item"><a href="/system/" class="nav-link">
  系统·设计
</a></div><div class="nav-item"><a href="/year/after/year/" class="nav-link">
  一年·一技
</a></div><div class="nav-item"><a href="https://github.com/muyids" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GITHUB
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  HOME
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  学习·笔记
</a></div><div class="nav-item"><a href="/blogs/" class="nav-link router-link-active">
  进阶·博文
</a></div><div class="nav-item"><a href="/code/" class="nav-link">
  编程·语言
</a></div><div class="nav-item"><a href="/alg/" class="nav-link">
  算法·练习
</a></div><div class="nav-item"><a href="/system/" class="nav-link">
  系统·设计
</a></div><div class="nav-item"><a href="/year/after/year/" class="nav-link">
  一年·一技
</a></div><div class="nav-item"><a href="https://github.com/muyids" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GITHUB
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>2017</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/2017/一致性hash算法.html" class="sidebar-link">一致性hash算法</a></li><li><a href="/blogs/2017/秒杀系统设计.html" class="sidebar-link">秒杀系统设计</a></li><li><a href="/blogs/2017/浅谈发布订阅.html" class="sidebar-link">浅谈发布订阅</a></li><li><a href="/blogs/2017/乐观锁和悲观锁.html" class="sidebar-link">乐观锁和悲观锁</a></li><li><a href="/blogs/2017/常见性能优化策略.html" class="sidebar-link">常见性能优化策略</a></li><li><a href="/blogs/2017/定时任务浅谈.html" class="sidebar-link">定时任务浅谈</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>2019</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/2019/限流算法.html" class="sidebar-link">限流算法</a></li><li><a href="/blogs/2019/分布式ID系统设计.html" class="sidebar-link">分布式ID系统设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>2020</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/2020/redis使用lua脚本实现分布式锁.html" class="sidebar-link">redis使用lua脚本实现分布式锁</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>计算机网络知识点总结</p> <h2 id="概念引入"><a href="#概念引入" class="header-anchor">#</a> 概念引入</h2> <ul><li><a href="#%E7%AE%80%E8%BF%B0osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B">简述OSI七层模型</a></li> <li><a href="#%E6%8F%8F%E8%BF%B0%E4%BB%8E%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5url%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">一个url从输入到访问经过了哪些过程</a></li></ul> <h2 id="网络层相关"><a href="#网络层相关" class="header-anchor">#</a> 网络层相关</h2> <ul><li><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82">网络层的作用，都有哪些协议</a></li> <li><a href="#ip%E5%88%86%E7%B1%BB">IP分类</a></li> <li><a href="#nat%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">NAT网络地址转换</a></li></ul> <h2 id="传输层相关"><a href="#传输层相关" class="header-anchor">#</a> 传输层相关</h2> <ul><li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82">传输层的功能</a></li> <li><a href="#tcp%E5%92%8Cudp%E7%9A%84%E5%8C%BA%E5%88%AB">TCP和UDP的区别</a> <ul><li><a href="#udp%E7%89%B9%E7%82%B9">UDP协议特点</a></li> <li><a href="#tcp%E7%89%B9%E7%82%B9">TCP协议特点</a></li></ul></li> <li><a href="#tcp%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%8B%E6%AE%B5%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BA%A4%E4%BB%98">TCP有哪些手段保证可靠交付</a></li> <li><a href="#tcp%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP流量控制</a></li> <li><a href="#tcp%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP拥塞控制</a></li> <li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">三次握手和四次挥手</a></li> <li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%96%AD%E8%BF%9E%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86">客户端断连怎么处理</a></li></ul> <h2 id="应用层相关"><a href="#应用层相关" class="header-anchor">#</a> 应用层相关</h2> <ul><li><a href="#%E5%BA%94%E7%94%A8%E5%B1%82">应用层的功能</a></li> <li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%92%8C%E5%BA%94%E7%94%A8%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB">传输层和应用层之间的关系</a></li> <li><a href="#%E7%AE%80%E8%BF%B0dns">DNS</a> <ul><li><a href="#dns%E8%A7%A3%E6%9E%90%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B">DNS解析的详细过程</a></li> <li><a href="#dns%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86">DNS优化原理</a></li> <li><a href="#dns%E7%BC%93%E5%AD%98">DNS缓存</a></li></ul></li> <li><a href="#%E7%AE%80%E8%BF%B0http%E5%8D%8F%E8%AE%AE">http协议</a> <ul><li><a href="#%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%AD%97%E6%AE%B5">常见请求头字段</a></li> <li><a href="#get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB">GET和POST的区别</a></li> <li><a href="#http%E7%8A%B6%E6%80%81%E7%A0%81">HTTP所有状态码的具体含义</a></li> <li><a href="#http%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">HTTP各个版本之间的区别</a></li></ul></li> <li><a href="#websocket%E5%8D%8F%E8%AE%AE">WebSocket协议</a> <ul><li><a href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86">底层原理</a></li> <li><a href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9">有哪些优点</a></li> <li><a href="#%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B">连接建立过程</a></li> <li><a href="#%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F">数据帧格式</a></li> <li><a href="#%E5%AE%89%E5%85%A8">安全</a></li></ul></li> <li><a href="#cdn%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86">CDN的作用和原理</a></li></ul> <h2 id="网络安全相关"><a href="#网络安全相关" class="header-anchor">#</a> 网络安全相关</h2> <ul><li><a href="#cookie">cookie</a></li> <li><a href="#oauth2.0">OAuth2.0</a></li> <li><a href="#%E8%B7%A8%E5%9F%9F">跨域</a></li> <li><a href="#ssl%E5%8A%A0%E5%AF%86%E7%9A%84%E8%BF%87%E7%A8%8B">ssl加密的过程</a> <ul><li><a href="#%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AFhttps">如何开启HTTPS</a></li> <li><a href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7">如何验证数字证书的有效性</a></li></ul></li> <li><a href="#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a></li> <li><a href="#xss%E6%94%BB%E5%87%BB">XSS攻击</a></li> <li><a href="#csrf%E6%94%BB%E5%87%BB">CSRF攻击</a></li></ul> <hr> <h2 id="简述osi七层模型"><a href="#简述osi七层模型" class="header-anchor">#</a> 简述OSI七层模型</h2> <p>OSI七层网络模型,自底向上描述（最好说明每个层干什么，举例网络协议，都在哪个层）</p> <p><img src="https://muyids.oss-cn-beijing.aliyuncs.com/osi-seven-level.png" alt="OSI七层模型、四层模型"></p> <ul><li>物理层: 建立、维护、断开物理连接</li> <li>数据链路层: 将二进制流 组合成 <em>帧</em>; <em>帧编码</em>和<em>误差纠正控制</em></li> <li>网络层: 提供主机间的逻辑通信；路由选择、路由及逻辑寻址;负责根据网络地址传送数据包；协议：IP, ARP, RARP, ICMP</li> <li>传输层: 提供应用进程间的逻辑通信。负责将数据<em>可靠地</em>传送到相应的<em>端口</em>。协议：TCP，UDP</li> <li>表示层：数据的表示、安全、压缩。</li> <li>会话层：建立、管理、中止会话。</li> <li>应用层: 为<strong>操作系统或网络应用程序</strong>提供访问网络服务的接口。协议：FTP,HTTP,DNS</li></ul> <h3 id="物理层"><a href="#物理层" class="header-anchor">#</a> 物理层</h3> <p>建立、维护、断开物理连接</p> <ul><li>物理接口信号线的规格；包括：形状和尺寸、引线数目和排列、固定和锁定装置等;</li> <li>传输二进制位流的标准；包括：传输二进制位流时线路上信号电压高低、阻抗匹配情况、传输速率和距离的限制等。</li></ul> <p>传输数据单位：比特流，二进制流 也就是所谓电流</p> <h3 id="数据链路层"><a href="#数据链路层" class="header-anchor">#</a> 数据链路层</h3> <p>将二进制流 组合成 <em>帧</em></p> <p>数据链路层主要有两个功能 ：<em>帧编码</em>和<em>误差纠正控制</em>。</p> <p>数据链路层的主要协议有：</p> <ul><li>帧中继（Frame Relay);</li> <li>点对点协议（Point-to-Point Protocol);</li> <li>以太网（Ethernet);</li> <li>高级数据链路协议(High-Level Data Link Protocol);</li> <li>异步传输模式(Asynchronous Transfer Mode);</li></ul> <h3 id="网络层"><a href="#网络层" class="header-anchor">#</a> 网络层</h3> <p>网络层：实现端端节点到端节点间的通信</p> <p>功能：路由选择、路由及逻辑寻址</p> <p>网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。</p> <p>协议：</p> <ul><li><p>IP（IPV4 IPV6）通过IP地址进行路由选择</p></li> <li><p>ARP“AddressResolutionProtocol”（地址解析协议）将IP地址转换为MAC地址</p></li> <li><p>RARP 逆地址解析</p></li> <li><p>ICMP 差错报告和查询</p> <p>由于IP协议的两个缺陷：没有差错控制和查询机制，因此产生了ICMP。ICMP主要是为了提高IP数据报成功交付的机会，在IP数据报传输的过程中进行差错报告和查询，比如目的主机或网络不可到达，报文被丢弃，路由阻塞，查询目的网络是否可以到达等等。</p></li></ul> <h3 id="传输层"><a href="#传输层" class="header-anchor">#</a> 传输层</h3> <p>网络层负责根据<strong>网络地址</strong>传送数据包</p> <p>传输层负责将数据<strong>可靠地</strong>传送到相应的<strong>端口</strong>。</p> <p>传输层的服务一般要经历传输连接建立阶段，数据传送阶段，传输连接释放阶段3个阶段才算完成一个完整的服务过程</p> <p>在这一层，信息传送的协议数据单元称为<em>数据段</em>或<em>报文</em>。</p> <p>传输层提供了主机应用程序进程之间的端到端的服务，基本功能如下：</p> <ul><li>分割与重组数据 （网络层发送的数据包可能是黏在一起的）</li> <li>端口号寻址 （我要知道发送给主机的哪个端口）</li> <li>连接管理 （建立tcp或udp连接）</li> <li>差错控制和流量控制、纠错 （保证传输质量；拥塞控制）</li></ul> <p>传输层要向会话层提供通信服务的可靠性，避免报文的出错、丢失、延迟时间紊乱、重复、乱序等差错。</p> <p>传输层既是OSI层模型中负责数据通信的最高层，并向高层用户屏蔽通信子网的细节。</p> <p>协议：</p> <ul><li>传输控制协议TCP（Transmission Control Protocol）</li> <li>用户数据报协议UDP（User Datagram Protocol）</li></ul> <p><strong>TCP在不可靠的IP网络层上提供了一个可靠的传输层</strong></p> <h3 id="会话层"><a href="#会话层" class="header-anchor">#</a> 会话层</h3> <p>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）</p> <p>对应主机进程，指本地主机与远程主机正在进行的会话</p> <p>运输服务质量参数(QOS)等会话的属性在这一层设置(MQTT协议中 0:最多一次，1：最少1次，2：只一次)</p> <h3 id="表示层"><a href="#表示层" class="header-anchor">#</a> 表示层</h3> <p>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）</p> <p>格式有，JPEG、ASCll、DECOIC、加密格式等</p> <h3 id="应用层"><a href="#应用层" class="header-anchor">#</a> 应用层</h3> <p>网络服务与最终用户的一个接口。</p> <p>应用层为<strong>操作系统或网络应用程序</strong>提供访问网络服务的接口。</p> <p>应用层协议的代表包括：Telnet、FTP、HTTP、DNS（Domain Name System：域名系统）等。</p> <p>简化后四层模型：物理层，网络层，传输层，应用层</p> <h2 id="描述从在浏览器地址栏输入url到浏览器加载，中间发生了什么"><a href="#描述从在浏览器地址栏输入url到浏览器加载，中间发生了什么" class="header-anchor">#</a> 描述从在浏览器地址栏输入URL到浏览器加载，中间发生了什么</h2> <ul><li>用户输入请求地址</li> <li>根据请求地址获取主机地址HOST, DNS解析返回IP地址
<ul><li>浏览器缓存 -&gt; host -&gt; 路由缓存 -&gt; 本地DNS -&gt;  根域名、顶级、二级、三级...</li> <li>先查本地缓存，本地缓存没有，依次请求根域名、顶级、二级、三级...DNS服务器，直到找到IP地址</li> <li>本地域名服务器缓存DNS信息，留着下次用</li></ul></li> <li>浏览器拿到IP后，就向服务器发送http连接请求，TCP三次握手</li> <li>防火墙将外网IP转换到内网IP，此步骤是通过<code>NAT地址转换</code></li> <li>请求到达LVS服务</li> <li>LVS反向代理到业务服务器，服务器返回数据，流量从防火墙出去</li> <li>浏览器接收到请求，进行处理，
<ul><li>解析请求是2XX,正常显示；3XX，进行转发，4XX或5XX，显示错误</li></ul></li> <li>断开连接, TCP四次挥手</li></ul> <h2 id="ip分类"><a href="#ip分类" class="header-anchor">#</a> IP分类</h2> <p>四个级别，分别为A类、B类、C类和D类。分类的依据是IP地址的前四位：</p> <ul><li><p>A类IP地址是第一位为“0”的地址。A类IP地址的前8位是网络标识，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个。</p></li> <li><p>B类IP地址是前两位为“10“的地址。B类IP地址的前16位是网络标识，用十进制标识的话<code>128.0.0.0-191.255.0.0</code>是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。</p></li> <li><p>C类IP地址是前三位为“110”的地址。C类IP地址的前24位是网络标识，用十进制标识的话<code>192.0.0.0-223.255.255.0</code>是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。</p></li> <li><p>D类IP地址是前四位为“1110”的地址。D类IP地址的网络标识长32位，没有主机标识，因此常用于多播。</p></li></ul> <h2 id="nat网络地址转换"><a href="#nat网络地址转换" class="header-anchor">#</a> NAT网络地址转换</h2> <p>NAT英文全称是“Network Address Translation”，中文意思是“网络地址转换”</p> <p><em>解决公网地址不足的问题</em></p> <p>把内部私有网络地址（IP地址）翻译成合法网络IP地址的技术。</p> <p>NAT名字很准确，网络地址转换，就是替换IP报文头部的地址信息</p> <p>网络被分为私网和公网两个部分，NAT网关设置在私网到公网的路由出口位置，双向流量必须都要经过NAT网关</p> <h2 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="header-anchor">#</a> TCP和UDP的区别</h2> <table><thead><tr><th style="text-align:center;">协议</th> <th style="text-align:center;">连接性</th> <th style="text-align:center;">双工性</th> <th style="text-align:center;">可靠性</th> <th style="text-align:center;">有序性</th> <th style="text-align:center;">有界性</th> <th style="text-align:center;">拥塞控制</th> <th style="text-align:center;">传输速度</th> <th style="text-align:center;">量级</th> <th style="text-align:center;">头部大小</th></tr></thead> <tbody><tr><td style="text-align:center;">TCP</td> <td style="text-align:center;">面向连接(Connection oriented)</td> <td style="text-align:center;">全双工(1:1)</td> <td style="text-align:center;">可靠(重传机制)</td> <td style="text-align:center;">有序(通过SYN排序)</td> <td style="text-align:center;">无边界</td> <td style="text-align:center;">有粘包情况</td> <td style="text-align:center;">有拥塞控制</td> <td style="text-align:center;">传输速度慢</td> <td style="text-align:center;">量级低</td></tr> <tr><td style="text-align:center;">UDP</td> <td style="text-align:center;">无连接(Connection less)</td> <td style="text-align:center;">n:m</td> <td style="text-align:center;">不可靠(丢包后数据丢失)</td> <td style="text-align:center;">无序</td> <td style="text-align:center;">有消息边界</td> <td style="text-align:center;">无粘包</td> <td style="text-align:center;">无拥塞控制</td> <td style="text-align:center;">传输速度快</td> <td style="text-align:center;">量级高</td></tr></tbody></table> <p>TCP应用场景：<code>将传输的文件分段</code>，<code>传输时需要建立会话</code>，<code>可靠传输</code>，<code>流量控制</code>；比如：下载一部电影</p> <p>UDP应用场景：<code>一个数据包就能完成数据通信</code>，<code>不分段</code>，<code>不建立会话</code>，<code>不需要流量控制</code>，<code>不可靠传输</code>；比如：DNS域名解析，QQ聊天，讲课时屏幕广播（多播，广播）</p> <p>TCP与UDP最大的不同是：<code>传输数据的质量</code></p> <p><a href="#tcp%E6%9C%89%E5%93%AA%E4%BA%9B%E6%89%8B%E6%AE%B5%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BA%A4%E4%BB%98">TCP如何保证传输数据的质量？</a></p> <p>答：序列号、检验和、ACK确认机制，流量控制，拥塞控制</p> <h2 id="udp特点"><a href="#udp特点" class="header-anchor">#</a> UDP特点</h2> <ul><li>无连接的</li> <li>尽最大努力交付，不可靠，不进行拥塞控制</li> <li>面向报文的，没有拥塞控制，适合多媒体通信的要求</li> <li>支持一对一，一对多，多对一，多对多通信</li> <li>首部开销小，只有8个字节</li></ul> <h2 id="tcp特点"><a href="#tcp特点" class="header-anchor">#</a> TCP特点</h2> <p>传输控制协议</p> <ul><li>面向连接的传输层协议</li> <li>只能是点对点的</li> <li>提供可靠交付；拥塞控制</li> <li>提供全双工通信</li> <li>面向字节流</li></ul> <h2 id="tcp有哪些手段保证可靠交付"><a href="#tcp有哪些手段保证可靠交付" class="header-anchor">#</a> TCP有哪些手段保证可靠交付</h2> <p>TCP通过<code>拆包、序列号、检验和、确认机制、重发控制、连接管理、流量控制、拥塞控制</code>实现可靠性。</p> <ol><li>拆包；应用数据被分割成 TCP 认为最适合发送的数据块。</li> <li>序列号；TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li> <li>校验和；TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li> <li>去重：TCP 的接收端会丢弃重复的数据。</li> <li>流量控制：TCP 利用<strong>可变大小的滑动窗口协议</strong>实现流量控制</li> <li>拥塞控制：当网络拥塞时，减少数据的发送。</li> <li>超时重发机制：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol> <h2 id="tcp流量控制"><a href="#tcp流量控制" class="header-anchor">#</a> TCP流量控制</h2> <p>TCP 利用<strong>可变大小的滑动窗口协议</strong>实现流量控制</p> <ul><li>TCP 连接的<code>发送方</code>和<code>接收方</code>都有固定大小的缓冲空间</li> <li>TCP的<strong>接收端只允许发送端发送接收端缓冲区能接纳的数据</strong></li> <li>当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失</li> <li>TCP 使用的流量控制协议是<strong>可变大小的滑动窗口协议</strong></li></ul> <h3 id="具体解释滑动窗口协议"><a href="#具体解释滑动窗口协议" class="header-anchor">#</a> 具体解释滑动窗口协议</h3> <p>发送窗口中有四个概念：</p> <ul><li>已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）</li> <li>已发送但未收到确认的数据（位于发送窗口之内）</li> <li>允许发送但尚未发送的数据（位于发送窗口之内）</li> <li>发送窗口之外的缓冲区内暂时不允许发送的数据</li></ul> <p>接收窗口中也有四个概念：</p> <ul><li>已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）</li> <li>未按序收到的数据（位于接收窗口之内）</li> <li>允许接收的数据（位于接收窗口之内）</li> <li>不允许接收的数据（位于发送窗口之内）</li></ul> <p><img src="https://muyids.oss-cn-beijing.aliyuncs.com/tcp-slide-window.png" alt="滑动窗口协议"></p> <p><strong>接收方通过报文告知发送方还可以发送多少数据</strong>，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况。</p> <h2 id="tcp拥塞控制"><a href="#tcp拥塞控制" class="header-anchor">#</a> TCP拥塞控制</h2> <p>一个门限：慢启动门限 ssthresh</p> <p>三个窗口：</p> <ul><li>接收窗口 rwnd (receive window)</li> <li>发送窗口 swnd(send window)</li> <li>拥塞窗口 cwnd(congestion window)</li></ul> <p>出现拥塞时，网络吞吐量会随输入负荷的增大而下降，因此要进行拥塞控制。</p> <p>TCP拥塞控制算法（TCP congestion control algorithm），主要包括4个步骤：</p> <ol><li>慢启动；指数增长</li> <li>拥塞避免；线性增长</li> <li>拥塞发生；拥塞发生时</li> <li>快重传和快恢复；拥塞发生后的恢复过程
<ol><li>快重传：TCP认为这种情况太糟糕，ssthresh = cwnd /2；cwnd = 1，重新进入慢启动</li> <li>快恢复：拥塞没那么糟糕；ssthresh = cwnd /2；cwnd = cwnd / 2，重新进入拥塞避免</li></ol></li></ol> <p><img src="https://muyids.oss-cn-beijing.aliyuncs.com/tcp-congestion-control-algorithm.png" alt="TCP拥塞控制算法"></p> <p><strong>慢启动（slow-start）算法原理</strong></p> <p>开始发送一个报文段，收到确认后拥塞窗口翻倍。然后传输2个报文段，收到2个确认后增加拥塞窗口变成了4个MSS。
这样没经过一个RTT，发送速率就会翻番。于是，TCP发送的起始速率慢，但是在慢启动阶段会以指数增长。</p> <p><strong>拥塞避免</strong></p> <p>进入拥塞状态后，TCP的cwnd增加速率就比较缓慢，一个RTT将cwnd的值增加一个MSS，线性增长。</p> <p><strong>快速恢复</strong></p> <p>在快速恢复中，对于引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余的ACK，cwnd的值都增加一个MSS。
最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。</p> <p>当TCP通信开始后, 网络吞吐量会逐渐上升; 随着网络发生拥堵, 吞吐量会立刻下降;</p> <p><strong>拥塞控制</strong>, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案.</p> <h2 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="header-anchor">#</a> 三次握手和四次挥手</h2> <h3 id="三次握手"><a href="#三次握手" class="header-anchor">#</a> 三次握手</h3> <p><img src="https://muyids.oss-cn-beijing.aliyuncs.com/tcp-three-hand-shake.png" alt="三次握手"></p> <ol><li>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认</li> <li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECEIVED状态；</li> <li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），客户端进入ESTABLISHED（TCP连接成功）状态，服务端收到客户端发来的ACK后，进入ESTABLISHED状态，完成三次握手。</li></ol> <h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="header-anchor">#</a> 为什么要三次握手</h3> <p><strong>为了确保双发收发都是正常的</strong>。</p> <p>简述tcp连接时的握手过程，不要第三次握手行不行？为什么不能用两次握手进行连接？</p> <ol><li>原因1：没有第三次握手，服务端不知道客户端是否成功拿到了自己发送的SYN，即不能确定客户端能收到服务端发送的消息</li> <li>原因2：如果使用两次握手，服务端接收客户端SYN后，进入ESTABLISHED状态；假设存在场景，客户端发起第一次连接超时，然后客户端发起第二次连接正常并传送数据断开，此时第一次连接到达服务端，这时服务端以为客户端又要建立第二次连接，进入ESTABLISHED状态，造成资源浪费；</li></ol> <h3 id="四次挥手"><a href="#四次挥手" class="header-anchor">#</a> 四次挥手</h3> <p><img src="https://muyids.oss-cn-beijing.aliyuncs.com/tcp-four-shake-hand.png" alt="四次挥手"></p> <ol><li>第一次挥手: 客户端数据发送完成，向服务端发送释放连接的请求。客户端进入FIN_WAIT_1状态。</li> <li>第二次挥手：服务端接收到客户端的连接释放请求，会告诉应用层要释放TCP连接。然后发送ACK到客户端，然后进入CLOSE_WAIT状态。此时表明客户端到服务端的连接已经释放，不会接受来自客户端的数据了，但是由于TCP是全双工。所以此时服务端还可以向客户端发送数据。</li> <li>第三次挥手：服务端如果在此时数据还没有发送完成，会继续发送，在数据发送完毕之后。服务端会向客户端发送连接释放的请求。然后服务端进入LAST_ACK状态。</li> <li>第四次挥手：客户端在接受到服务端的释放请求。会向服务端在发送一个确认请求。此时客户端进入TIME_WAIT状态
该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 服务端的重发请求的话，就进入 CLOSED 状态。当 客户端收到确认应答后，也便进入 CLOSED 状态。</li></ol> <h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="header-anchor">#</a> 为什么要四次挥手</h3> <p><strong>双方数据发送完毕，都认为可以断开</strong></p> <ul><li>当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。</li> <li>只有等到<strong>Server端所有的报文都发送完</strong>了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</li></ul> <h2 id="客户端断连怎么处理"><a href="#客户端断连怎么处理" class="header-anchor">#</a> 客户端断连怎么处理</h2> <p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p> <p>TCP设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p> <h2 id="传输层和应用层之间的关系"><a href="#传输层和应用层之间的关系" class="header-anchor">#</a> 传输层和应用层之间的关系</h2> <p>传输层的协议TCP或UDP加上端口就可以标识一个应用层协议</p> <p><strong>应用层 = 传输层 + 端口</strong></p> <p>常见应用层协议</p> <ul><li>http = tcp + 80</li> <li>https = tcp + 443</li> <li>RDP = tcp + 3389 # 远程桌面</li> <li>ftp = tcp + 21</li> <li>共享文件夹 = tcp+445</li> <li>SMTP = tcp + 25 # 发邮件</li> <li>pop3 = tcp + 110 # 收邮件</li> <li>telnet = tcp + 23</li> <li>dns = tcp + 53</li></ul> <h2 id="简述dns"><a href="#简述dns" class="header-anchor">#</a> 简述DNS</h2> <p>DNS（Domain Name System）: 域名系统</p> <p>是<em>域名解析服务器</em>组成的<em>服务系统</em></p> <h3 id="dns解析的详细过程"><a href="#dns解析的详细过程" class="header-anchor">#</a> DNS解析的详细过程</h3> <ul><li>客户机提出域名解析请求，并将该请求发送给本地的域名服务器。</li> <li>当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该纪录项，则本地的域名服务器就直接把查询的结果返回。</li> <li>若没有查到，则将请求发给根域 DNS 服务器，并依序从根域查找顶级域，由顶级查找二级域，二级域查找三级，直至找到要解析的地址或名字，即向客户机所在网络的DNS服务器发出应答信息，DNS 服务器收到应答后先在缓存中存储，然后，将解析结果发给客户机。若没有找到，则返回错误信息。</li> <li>本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机。</li></ul> <h3 id="dns优化原理"><a href="#dns优化原理" class="header-anchor">#</a> DNS优化原理</h3> <ul><li>DNS缓存</li> <li>DNS负载均衡
<ul><li>在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</li></ul></li></ul> <h3 id="dns缓存"><a href="#dns缓存" class="header-anchor">#</a> DNS缓存</h3> <p>我们有时会遇到一种情况：ip可以访问，域名地址访问失败，这是怎么回事呢？</p> <p>原因：域名解析失败，往往是因为DNS缓存的问题。</p> <p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种:</p> <p>浏览器缓存，系统缓存，路由器缓存，ISP（电信运营商）缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p> <p><em>多级DNS服务器，每一级DNS服务器如何去缓存，缓存刷新时长?</em></p> <p>浏览器缓存</p> <p>chrome://net-internals/#dns 这里可以看各域名的DNS 缓存时间。Chrome对每个域名会默认缓存60s。</p> <p>ISP（电信运营商）缓存</p> <p>有些不靠谱，有些缓存服务器（不多）会忽略网站DNS提供的TTL，自己设置一个较长的TTL，
导致顶级DNS更新时不能及时拿到新的IP地址</p> <p><em>缓存是双刃剑，提高了获取DNS的速度，也会影响DNS在IP变更时不能及时更新到最新。</em></p> <h2 id="简述http协议"><a href="#简述http协议" class="header-anchor">#</a> 简述http协议</h2> <p>http协议是在tcp/ip协议之上的应用层规范</p> <p>http请求分为4部分：状态行，请求头，空行，消息体</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>常用的四种方法：GET，POST，PUT，DELETE用来 查，增，改，删四种操作</p> <h2 id="常见请求头字段"><a href="#常见请求头字段" class="header-anchor">#</a> 常见请求头字段</h2> <ul><li>Accept ： 规定可接受的 response 的 Media type(s) 类型。  Accept: text/html</li> <li>Authorization ： HTTP认证的凭据（最基本的格式：该凭据是用户名+密码）。是最简单的资源访问限制的实现方法。  ；Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</li> <li>Cache-Control ：Cache-Control是no-cache，是浏览器通知服务器：本地没有缓存数据; Cache-Control:max-age=259200 是通知浏览器：259200 秒之内别来烦我，自己从缓冲区中刷新</li> <li>Content-Type  ：请求体的类型  ；Content-Type: application/x-www-form-urlencoded</li> <li>Cookie  ：该字段的值会同时被存储到浏览器端；Cookie: $Version=1; Skin=new;</li> <li>Etag:特定版本资源的标识符，通常是消息摘要。ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</li></ul> <h2 id="get和post的区别"><a href="#get和post的区别" class="header-anchor">#</a> GET和POST的区别</h2> <h3 id="使用上"><a href="#使用上" class="header-anchor">#</a> 使用上</h3> <p>GET 是安全的和幂等的</p> <div class="language-http get line-numbers-mode"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /books/?sex=man&amp;name=Professional HTTP/1.1</span>
<span class="token header-name keyword">Host:</span> www.example.com
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
<span class="token header-name keyword">Connection:</span> Keep-Alive
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>POST 用于改变服务器上的资源</p> <div class="language-http post line-numbers-mode"><pre class="language-http"><code>POST / HTTP/1.1
<span class="token header-name keyword">Host:</span> www.example.com
<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
<span class="token header-name keyword">Content-Type:</span> application/x-www-form-urlencoded
<span class="token header-name keyword">Content-Length:</span> 40
<span class="token header-name keyword">Connection:</span> Keep-Alive

sex=man&amp;name=Professional  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="原理上"><a href="#原理上" class="header-anchor">#</a> 原理上</h3> <ul><li><p>GET和POST是HTTP定义的两种不同方法，本质上都是TCP链接，并无差别</p></li> <li><p>有一个重大差别是，<strong>GET产生一个TCP数据包；POST产生两个TCP数据包</strong></p> <ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</li> <li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li></ul></li> <li><p>但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p> <ul><li>GET用来获取资源，POST用来上传资源</li> <li>GET参数通过URL传递，POST放在URL和body中</li> <li>GET只能有ASCII码的编码方式提交请求，POST的数据编码格式没有规定</li> <li>GET可提交的数据量受URL长度限制（浏览器规定url长度&lt;2k,服务器一般只处理64k以下的数据），POST一般不受限制</li> <li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li> <li>GET在浏览器<strong>回退时</strong>是无害的，而POST会再次提交请求。</li></ul></li></ul> <h2 id="http状态码"><a href="#http状态码" class="header-anchor">#</a> HTTP状态码</h2> <p>状态码系列：</p> <ul><li>1XX：通知</li> <li>2XX: 成功</li> <li>3XX 重定向</li> <li>4XX：客户端错误</li> <li>5XX 服务端错误</li></ul> <p>基本响应代码：</p> <ul><li>200(&quot;OK&quot;)
<ul><li>一切正常。实体主体中的文档（若存在的话）是某资源的表示</li></ul></li> <li>400(&quot;Bad Request&quot;)
<ul><li>客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。</li></ul></li> <li>500(&quot;Internal Server Error&quot;)
<ul><li>服务期方面的问题。实体主体中的文档（如果存在的话）是一个错误消息。该错误消息通常无济于事，因为客户端无法修复服务器方面的问题。</li></ul></li> <li>301(&quot;Moved Permanently&quot;)
<ul><li>当客户端触发的动作引起了资源URI的变化时发送此响应代码。另外，当客户端向一个资源的旧URI发送请求时，也发送此响应代码。</li></ul></li> <li>404(&quot;Not Found&quot;) 和410(&quot;Gone&quot;)
<ul><li>当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。</li></ul></li> <li>409(&quot;Conflict&quot;)
<ul><li>当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。</li></ul></li></ul> <p>SOAP Web服务只使用响应代码200(&quot;OK&quot;)和500(&quot;Internal Server Error&quot;)。无论是你发给SOAP服务器的数据有问题，还是服务器在处理数据的过程中出现问题，或者SOAP服务器出现内部问题，SOAP服务器均发送500(&quot;Internal Server Error&quot;)。</p> <h2 id="http各个版本之间的区别"><a href="#http各个版本之间的区别" class="header-anchor">#</a> HTTP各个版本之间的区别</h2> <h3 id="http0-9"><a href="#http0-9" class="header-anchor">#</a> http0.9</h3> <p>最初的http版本，<strong>仅支持get方法，只能传输纯文本内容</strong></p> <p>请求结束服务后会给客户端返回一个HTML格式的字符串，然后由浏览器自己渲染。</p> <p>http0.9是典型的无状态连接</p> <h3 id="http1-0"><a href="#http1-0" class="header-anchor">#</a> http1.0</h3> <ul><li>本质上支持长连接，但是<strong>默认还是短连接</strong>，增加了<strong>keep-alive</strong>关键字来由短链接变成长连接。</li> <li>HTTP的请求和回应格式也发生了变化，除了要传输的数据之外，每次通信都包含头信息，用来描述一些信息。</li> <li>还增加了状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等</li></ul> <h3 id="http1-1"><a href="#http1-1" class="header-anchor">#</a> http1.1</h3> <ul><li>HTTP1.1最大的变化就是引入了长链接，也就是<strong>TCP链接默认是不关闭的</strong>可以<strong>被多个请求复用</strong>。</li> <li>客户端或者服务器如果长时间发现对方没有活动就会<strong>关闭链接</strong>，但是规范的做法是客户端在最后一个请求的时候要求服务器关闭链接。</li> <li><strong>节约带宽</strong>，HTTP1.1支持<strong>只发送header头</strong>信息不带任何body信息，如果服务器认为客户端有权限请求指定数据那就返回100，没有就返回401，当客户端收到100的时候可以才把要请求的信息发给服务器</li> <li>并且1.1还支持了<strong>请求部分内容</strong>，如果当前客户端已经有一部分资源了，只需要向服务器请求另外的部分资源即可，这也是支持文件<strong>断点续传</strong>的基础。</li></ul> <h3 id="http2-0"><a href="#http2-0" class="header-anchor">#</a> http2.0</h3> <ul><li><strong>多路复用</strong>：在一个连接里面并发处理请求，不像http1.1在一个tcp连接中各个请求是串行的。花销很大</li> <li>在1.0版本后增加了header头信息，2.0版本通过算法把<strong>header进行了压缩</strong>这样数据体积就更小，在网络上传输就更快。</li> <li><strong>服务端有了推送功能</strong>，将客户端感兴趣的东西推给客户端，当客户端请求这些时，直接去缓存中取就行。</li></ul> <h2 id="websocket协议"><a href="#websocket协议" class="header-anchor">#</a> WebSocket协议</h2> <h3 id="底层原理"><a href="#底层原理" class="header-anchor">#</a> 底层原理</h3> <ul><li>基于TCP传输协议，并复用HTTP的握手通道</li></ul> <h3 id="有哪些优点"><a href="#有哪些优点" class="header-anchor">#</a> 有哪些优点</h3> <p>对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。</p> <ul><li>支持双向通信，实时性更强。</li> <li>更好的二进制支持。</li> <li>较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。</li> <li>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）</li></ul> <h3 id="连接建立过程"><a href="#连接建立过程" class="header-anchor">#</a> 连接建立过程</h3> <ol><li>首先，WebSocket复用了HTTP的握手通道</li> <li>具体是指：客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</li></ol> <h4 id="客户端：申请协议升级"><a href="#客户端：申请协议升级" class="header-anchor">#</a> 客户端：申请协议升级</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>GET / HTTP/1.1
Host: localhost:8080
Origin: http://127.0.0.1:3000
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>Connection: Upgrade：表示要升级协议</li> <li>Upgrade: websocket：表示要升级到websocket协议。</li> <li>Sec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li> <li>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接</li></ul> <h4 id="服务端：响应协议升级"><a href="#服务端：响应协议升级" class="header-anchor">#</a> 服务端：响应协议升级</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>状态代码101表示协议切换，后续的数据交互都按照新的协议来。</p> <h4 id="具体步骤"><a href="#具体步骤" class="header-anchor">#</a> 具体步骤</h4> <p>服务器端：</p> <ol><li>创建socket，绑定端口</li> <li>开始监听（listen）</li> <li>等待并接受客户端连接请求，返回新的socket（accept）</li> <li>由新socket与客户端进行io交互。</li> <li>关闭连接（可能主动，也可能被动）</li></ol> <p>客户端：</p> <ol><li>创建socket；先三次握手，然后发起<strong>申请协议升级请求</strong></li> <li>连接服务器（connect） 与服务器进行io交互</li> <li>关闭连接（可能主动，也可能被动） 以上是基于tcp协议的过程，udp更简单。</li></ol> <h3 id="数据帧格式"><a href="#数据帧格式" class="header-anchor">#</a> 数据帧格式</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>FIN：1个比特。1，表示这是消息（message）的最后一个分片（fragment），0，表示不是是消息（message）的最后一个分片（fragment）。</li> <li>Opcode: 4个比特。操作代码
<ul><li>%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</li> <li>%x1：表示这是一个文本帧（frame）</li> <li>%x2：表示这是一个二进制帧（frame）</li> <li>%x8：表示连接断开。</li> <li>%x9：表示这是一个ping操作。</li> <li>%xA：表示这是一个pong操作。</li></ul></li></ul> <h3 id="连接保持和心跳"><a href="#连接保持和心跳" class="header-anchor">#</a> 连接保持和心跳</h3> <ul><li>发送方-&gt;接收方：ping</li> <li>接收方-&gt;发送方：pong</li></ul> <p>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p> <h3 id="安全"><a href="#安全" class="header-anchor">#</a> 安全</h3> <h4 id="sec-websocket-key-sec-websocket-accept"><a href="#sec-websocket-key-sec-websocket-accept" class="header-anchor">#</a> Sec-WebSocket-Key/Sec-WebSocket-Accept</h4> <p>Sec-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。
计算公式为：</p> <ol><li>将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。</li> <li>通过SHA1计算出摘要，并转成base64字符串。</li></ol> <p><strong>Sec-WebSocket-Key/Sec-WebSocket-Accept</strong>主要作用在于<strong>提供基础的防护，减少恶意连接、意外连接</strong>。</p> <h4 id="数据掩码"><a href="#数据掩码" class="header-anchor">#</a> 数据掩码</h4> <p>增强协议的安全性, 但并不是为了防止数据泄密，而是为了防止<strong>早期版本的协议</strong>中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p> <h5 id="代理缓存污染攻击-todo"><a href="#代理缓存污染攻击-todo" class="header-anchor">#</a> 代理缓存污染攻击(TODO)</h5> <h4 id="鉴权授权"><a href="#鉴权授权" class="header-anchor">#</a> 鉴权授权</h4> <p>在 HTTP 切换到 Socket 之前，没有什么好的机会进行鉴权，因为在这个时间节点，报文（或者说请求的Headers）必须遵守协议规范。但这不妨碍我们在协议切换完成后，进行鉴权授权：</p> <h4 id="鉴权"><a href="#鉴权" class="header-anchor">#</a> 鉴权</h4> <ul><li>在连接建立时，检查连接的HTTP请求头信息（比如cookies中关于用户的身份信息）</li> <li>在每次接收到消息时，检查连接是否已授权过，及授权是否过期</li> <li>以上两点，只要答案为否，则服务端主动关闭socket连接</li></ul> <h4 id="授权"><a href="#授权" class="header-anchor">#</a> 授权</h4> <p>服务端在连接建立时，颁发一个ticket给peer端，这个ticket可以包含但不限于：</p> <ul><li>peer端的uniqueId（可以是ip，userid，deviceid…任一种具备唯一性的键）</li> <li>过期时间的timestamp</li> <li>token：由以上信息生成的哈希值，最好能加盐</li></ul> <h2 id="cdn的作用和原理"><a href="#cdn的作用和原理" class="header-anchor">#</a> CDN的作用和原理</h2> <p>CDN(Content Delivery Network):内容分发网络</p> <p>CDN是利用<strong>DNS的重定向技术</strong>，DNS服务器会返回一个<strong>跟用户最接近的点</strong>的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p> <h2 id="cookie"><a href="#cookie" class="header-anchor">#</a> cookie</h2> <p>三种web存储：localStorage、sessionStorage、cookie</p> <p>cookie定义：http是无状态协议，cookie就产生了，来标识会话，维护状态</p> <p>cookie就是一种浏览器管理状态的一个文件，其实就是一个小数据库的表结构，包括：name、value、Domain、path、expires, size 等等属性</p> <h3 id="cookie不可跨域"><a href="#cookie不可跨域" class="header-anchor">#</a> cookie不可跨域</h3> <p>不可跨域性，就是不能在不同的域名下用，每个cookie都会绑定单一的域名</p> <h3 id="cookie的属性"><a href="#cookie的属性" class="header-anchor">#</a> cookie的属性</h3> <ul><li>name</li> <li>value: 必须被URL编码</li> <li>domain
<ul><li>cookie绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域</li> <li>统一个域名下的二级域名也是不可以交换使用cookie的，比如，你设置www.baidu.com和image.baidu.com,依旧是不能公用的</li></ul></li> <li>path: 默认是'/'，这个值匹配的是web的路由;当你路径设置成/blog的时候，其实它会给/blog、/blogabc等等的绑定cookie</li> <li>Expires/max-age
<ul><li>Max-Age，是以秒为单位的，Max-Age为正数时，cookie会在Max-Age秒之后，被删除</li> <li>当Max-Age为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失</li> <li>当Max-Age为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效。</li></ul></li> <li>secure: 当这个属性设置为true时，此cookie只会在https和ssl等安全协议下传输</li> <li>HttpOnly(重要): 如果这个属性设置为true，就不能通过js脚本来获取cookie的值，能有效的防止xss攻击,</li></ul> <h3 id="服务端设置"><a href="#服务端设置" class="header-anchor">#</a> 服务端设置</h3> <p>通过Set-Cookie用键值对形式设置请求头</p> <h2 id="oauth2-0"><a href="#oauth2-0" class="header-anchor">#</a> OAuth2.0</h2> <p>OAuth授权所需信息：</p> <ol><li>应用名称</li> <li>应用网站</li> <li>重定向URI或回调URL（redirect_uri)</li> <li>客户端标识 client_id</li> <li>客户端密钥 client_secret</li></ol> <p>授权成功后，服务器 回调请求redirect_uri，客户端通过下发的code和自己的secret请求服务器得到access_token</p> <p><a href="https://www.bilibili.com/video/BV1zt41127hX" target="_blank" rel="noopener noreferrer">B站课程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <p>跨域是针对浏览器来说的，浏览器的同源策略 (地址里面的<strong>协议、域名和端口号</strong>均相同)</p> <p><strong>浏览器的同源策略</strong>: 一个请求在浏览器端发送出去后，是会收到返回值响应的，只不过浏览器在解析这个请求的响应之后，发现不属于浏览器的同源策略(地址里面的协议、域名和端口号均相同)，会进行拦截。如果是在<code>curl</code>里面发送一个请求，都是没有跨域这样一个概念的</p> <h3 id="基于http协议层面的几种解决办法"><a href="#基于http协议层面的几种解决办法" class="header-anchor">#</a> 基于http协议层面的几种解决办法</h3> <ul><li>设置<code>Access-Control-Allow-Origin</code></li> <li>jsonp</li> <li>CORS预请求</li></ul> <h4 id="设置access-control-allow-origin-headers-methods请求头"><a href="#设置access-control-allow-origin-headers-methods请求头" class="header-anchor">#</a> 设置Access-Control-Allow-Origin\Headers\Methods请求头</h4> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Headers&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Methods&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;GET, POST, PUT, OPTIONS&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>设置为<code>*</code>表示，可以接收任意域名的访问；</li> <li>也可以设置为特定域名访问</li> <li>如果有<code>多个域名</code>访问可以在服务端动态设置</li></ul> <h4 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> jsonp</h4> <p>浏览器是允许像link、img、script标签在路径上加载一些内容进行请求，是允许跨域的，
那么jsonp的实现原理就是在script标签里面加载了一个链接，去访问服务器的某个请求，返回内容。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://127.0.0.1:3011/xxx&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="cors预请求"><a href="#cors预请求" class="header-anchor">#</a> CORS预请求</h4> <p>“需预检的请求”要求必须首先使用<code>OPTIONS</code>方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。&quot;预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p> <h2 id="ssl加密的过程"><a href="#ssl加密的过程" class="header-anchor">#</a> ssl加密的过程</h2> <p>https是http + ssl或tls</p> <p>HTTPS的加密解密方式是<strong>非对称加密与对称加密的结合</strong></p> <p>SSL全名为<code>Secure Sockets Layer</code>; TLS(Transport Layer Security); 传输层安全协议。</p> <p>两种加密方式：</p> <ul><li>对称加密(共享密钥加密): 加密和解密同用一个密钥。加密时就必须将密钥传送给对方。</li> <li>非对称密钥加密: 使用一对非对称的密钥。一把叫做私有密钥，一把叫做公开密钥。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</li></ul> <p>非对称加密过程：</p> <ul><li>A：B，你好，我想向你发一段消息，请你把你的公钥给我</li> <li>B：好的，我的公钥是：xxxxxxx。</li> <li>A：好的，我收到了你的公钥，我给你发送的消息经过你的公钥加密后是：yyyyyyy。</li> <li>B：收到，我现在用我的密钥来解密看看。</li></ul> <p>由于<strong>非对称加密算法</strong>复杂度和计算量大，<strong>对称加密</strong>效率高，SSL就将这两种加密算法混合着用，这样安全和效率就都能保证了。其中具体的过程如下：</p> <p>SSL加密过程（非对称加密算法 + 对称加密）：</p> <ol><li>客户端A给出 支持的SSL版本+一个随机数+自己支持的加密方式</li> <li>服务端B接收到这些信息后确认加密方式+自己的安全证书+一个随机数发给A</li> <li>客户端A确认<strong>数字证书</strong>（验证服务端身份，防止中间人攻击）有效性，然后生成一个随机数，并将这个随机数用B的数字证书公钥加密后发送给B。</li> <li>服务端B使用自己的私钥解密这个随机数</li> <li>A和B通过第二步确定的加密方法将前三个随机数生成一个对话密钥（对称加密），用来接下来的通信</li></ol> <h3 id="如何开启https"><a href="#如何开启https" class="header-anchor">#</a> 如何开启HTTPS</h3> <p>申请一张SSL证书，然后将SSL证书部署到服务器端，开启443端口，就可以实现HTTPS访问了</p> <h3 id="如何验证数字证书的有效性"><a href="#如何验证数字证书的有效性" class="header-anchor">#</a> 如何验证数字证书的有效性</h3> <h4 id="数字证书有效期验证"><a href="#数字证书有效期验证" class="header-anchor">#</a> 数字证书有效期验证</h4> <p>证书的使用时间要在起始时间和结束时间之内</p> <h4 id="根证书验证"><a href="#根证书验证" class="header-anchor">#</a> 根证书验证</h4> <p>普通的证书一般包括三部分：用户信息，用户公钥，以及CA签名</p> <p>要验证这张证书就需要验证CA签名的真伪。那么就需要CA公钥。而CA公钥存在于另外一张证书（称这张证书是对普通证书签名的证书）中。因此我们又需要验证这另外一张证书的真伪。因此又需要验证另另外证书（称这张证书是对另外一张证书签名的证书）的真伪。依次往下回溯，就得到一条证书链。那么这张证书链从哪里结束呢？就是在根证书结束（即验证到根证书结束）。根证书是个很特别的证书，它是CA中心自己给自己签名的证书（即这张证书是用CA公钥对这张证书进行签名）。信任这张证书，就代表信任这张证书下的证书链。</p> <p>所有用户在使用自己的证书之前必须先下载根证书。</p> <p>所谓根证书验证就是：<strong>用根证书公钥来验证该证书的颁发者签名</strong>。所以首先必须要有根证书，并且根证书必须在受信任的证书列表（即信任域）。</p> <p>数字证书的信任是<strong>基于对CA根证书的信任的</strong></p> <h4 id="crl验证"><a href="#crl验证" class="header-anchor">#</a> CRL验证</h4> <p>CRL是经过CA签名的证书作废列表，用于证书冻结和撤销。一般来说证书中有CRL地址，供HTTP或者LDAP方式访问，通过解析可得到CRL地址，然后下载CRL进行验证。</p> <h2 id="中间人攻击"><a href="#中间人攻击" class="header-anchor">#</a> 中间人攻击</h2> <p>定义：<strong>中间人攻击是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</strong></p> <p>代理人攻击，在客户端和服务端之间做一层代理，获取两边信任，进行攻击</p> <p>防范手段：https + 可信任数字证书</p> <h2 id="xss攻击"><a href="#xss攻击" class="header-anchor">#</a> XSS攻击</h2> <p>跨站脚本攻击: 就是攻击者想尽一切办法<strong>将可以执行的代码注入到网页</strong>中。</p> <p>XSS 的全称是 <code>Cross Site Scripting</code> 也就是跨站脚本，当目标网站目标用户浏览器渲染HTML文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了</p> <p>对于 XSS 攻击来说，通常有两种方式可以用来防御:</p> <ol><li><strong>转义字符</strong></li> <li><strong>CSP(Content-Security-Policy)建立白名单</strong></li></ol> <h3 id="转义字符"><a href="#转义字符" class="header-anchor">#</a> 转义字符</h3> <p>用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</p> <p><code>escape('&lt;script&gt;alert(1)&lt;/script&gt;')</code> =&gt; <code>&amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</code></p> <p>对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> xss <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token function">xss</span><span class="token punctuation">(</span><span class="token string">'&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;'</span><span class="token punctuation">)</span>
<span class="token comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(&quot;xss&quot;);&amp;lt;/script&amp;gt;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="csp"><a href="#csp" class="header-anchor">#</a> CSP</h3> <p>CSP 本质上就是<strong>建立白名单</strong>，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。</p> <p>两种方式来开启 CSP：</p> <ol><li>设置 HTTP Header 中的 ==Content-Security-Policy==</li> <li>设置 ==meta== 标签的方式 ====</li></ol> <h4 id="以设置-http-header-来举例"><a href="#以设置-http-header-来举例" class="header-anchor">#</a> 以设置 HTTP Header 来举例</h4> <ol><li>只允许加载本站资源 <code>Content-Security-Policy: default-src ‘self’</code></li> <li>只允许加载 HTTPS 协议图片 <code>Content-Security-Policy: img-src https://*</code></li> <li>允许加载任何来源框架 <code>Content-Security-Policy: child-src 'none'</code></li></ol> <h2 id="csrf攻击"><a href="#csrf攻击" class="header-anchor">#</a> CSRF攻击</h2> <p><code>CSRF（Cross-site request forgery）</code>，中文名称：<strong>跨站请求伪造</strong>，也被称为：<code>one click attack/session riding</code>，缩写为：CSRF/XSRF。</p> <p>本质：<strong>攻击者盗用了你的身份，以你的名义发送恶意请求</strong></p> <p>手段：<strong>攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑</strong></p> <p>CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。</p> <h3 id="防御手段"><a href="#防御手段" class="header-anchor">#</a> 防御手段</h3> <ul><li>验证Referer；（服务端做Referer检查，阻止第三方网站请求接口；也不是万无一失的，发请求时我们可以篡改Referer的值）</li> <li>修改数据的敏感的操作应该使用POST；（攻击者也可以构造form提交，仅仅使用POST远远不够）</li> <li>请求时附带验证信息，比如验证码和token(csrftoken验证)</li> <li>csrftoken验证
<ul><li>在 HTTP 请求中以參数的形式添加一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，假设请求中没有token 或者 token 内容不对，则觉得可能是 CSRF 攻击而拒绝该请求。</li> <li>csrftoken产生的机制：客户端与服务端 指定token产生规则，客户端发送请求时带上自己生成的token；隐患：客户端被破解（反编译等）无法防范；</li></ul></li></ul> <p><a href="https://github.com/expressjs/csurf" target="_blank" rel="noopener noreferrer">Node.js增加csrftoken<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4ab909ce.js" defer></script><script src="/assets/js/2.268f4e54.js" defer></script><script src="/assets/js/110.e88d5e3b.js" defer></script>
  </body>
</html>
