(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{360:function(a,s,e){"use strict";e.r(s);var v=e(42),t=Object(v.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"redis主从模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis主从模式"}},[a._v("#")]),a._v(" Redis主从模式")]),a._v(" "),e("p",[a._v("Redis支持主从同步。")]),a._v(" "),e("p",[a._v("数据可以从主服务器向任意数量的从服务器上同步，同步使用的是发布/订阅机制。")]),a._v(" "),e("h3",{attrs:{id:"配置主从同步步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置主从同步步骤"}},[a._v("#")]),a._v(" 配置主从同步步骤")]),a._v(" "),e("ol",[e("li",[a._v("当配置好slave后，slave与master建立连接，然后slave发送sync命令")]),a._v(" "),e("li",[a._v("master都会启动一个后台进程，将 数据库快照保存到文件中（RDB），同时master主进程会开始收集新的写命令并缓存（AOF）")]),a._v(" "),e("li",[a._v("后台进程完成写文件后，master就发送文件给slave，slave将 文件保存到硬盘上，再加载到内存中，接着master就会把缓存的命令转发给slave，后续master将收到的写命令发送给slave。")]),a._v(" "),e("li",[a._v("可以是1 Master 多Slave，可以分层，Slave下可以再接Slave，可扩展成树状结构。")])]),a._v(" "),e("h3",{attrs:{id:"主从同步的应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从同步的应用"}},[a._v("#")]),a._v(" 主从同步的应用")]),a._v(" "),e("ol",[e("li",[a._v("用于对 数据的热备份")]),a._v(" "),e("li",[a._v("用于读写分离")])]),a._v(" "),e("h3",{attrs:{id:"主从同步的延迟问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主从同步的延迟问题"}},[a._v("#")]),a._v(" 主从同步的延迟问题")]),a._v(" "),e("p",[a._v("根据CAP原理，网络延迟问题只能优化，不能从根本上解决；")]),a._v(" "),e("p",[a._v("基于局域网的master/slave机制在通常情况下已经可以满足'实时'备份的要求了。如果延迟比较大，就先确认以下几个因素：")]),a._v(" "),e("ol",[e("li",[a._v("网络延迟")]),a._v(" "),e("li",[a._v("master负载")]),a._v(" "),e("li",[a._v("slave负载")])]),a._v(" "),e("p",[a._v("一般的做法是，使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器，只作为备份用，不进行其他任何操作，就能相对最大限度地达到'实时'的要求了")])])}),[],!1,null,null,null);s.default=t.exports}}]);