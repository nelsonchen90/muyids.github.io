(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{358:function(e,t,a){"use strict";a.r(t);var s=a(42),_=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"命名服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名服务"}},[e._v("#")]),e._v(" 命名服务")]),e._v(" "),a("p",[e._v("**命名服务是指通过指定的名字来获取资源或者服务地址。**Zookeeper可以创建一个全局唯一的路径，这个路径就可以作为一个名字。被命名的实体可以是集群中的机器，服务的地址，或者是远程的对象等。一些分布式服务框架（RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够根据特定的名字来获取资源的实体、服务地址和提供者信息等。")]),e._v(" "),a("h1",{attrs:{id:"配置管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置管理"}},[e._v("#")]),e._v(" 配置管理")]),e._v(" "),a("p",[e._v("实际项目开发中，我们经常使用"),a("code",[e._v(".properties")]),e._v("或者"),a("code",[e._v("xml")]),e._v("需要配置很多信息，如数据库连接信息、fps地址端口等等。因为你的程序一般是分布式部署在不同的机器上，如果把程序的这些配置信息保存在"),a("code",[e._v("zk的znode节点")]),e._v("下，当你要修改配置，即znode会发生变化时，可以通过改变zk中某个目录节点的内容，利用"),a("strong",[e._v("watcher通知")]),e._v("给各个客户端，从而更改配置。")]),e._v(" "),a("h1",{attrs:{id:"集群管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群管理"}},[e._v("#")]),e._v(" 集群管理")]),e._v(" "),a("p",[a("strong",[e._v("集群管理包括集群监控和集群控制")]),e._v("，其实就是监控集群机器状态，剔除机器和加入机器。zookeeper可以方便集群机器的管理，它可以实时监控znode节点的变化，一旦发现有机器挂了，该机器就会与zk断开连接，对用的临时目录节点会被删除，其他所有机器都收到通知。新机器加入也类似，所有机器收到通知。")]),e._v(" "),a("h1",{attrs:{id:"zookeeper的数据模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper的数据模型"}},[e._v("#")]),e._v(" zookeeper的数据模型")]),e._v(" "),a("p",[e._v("ZooKeeper的视图数据结构，很像Unix文件系统，也是树状的，这样可以确定"),a("strong",[e._v("每个路径都是唯一的")]),e._v("。zookeeper的节点统一叫做"),a("code",[e._v("znode")]),e._v("，它是可以通过"),a("strong",[e._v("路径")]),e._v("来标识")]),e._v(" "),a("h1",{attrs:{id:"znode的4种类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#znode的4种类型"}},[e._v("#")]),e._v(" znode的4种类型")]),e._v(" "),a("p",[e._v("根据节点的生命周期，znode可以分为4种类型，分别是持久节点（PERSISTENT）、持久顺序节点（PERSISTENT_SEQUENTIAL）、临时节点（EPHEMERAL）、临时顺序节点（EPHEMERAL_SEQUENTIAL）")]),e._v(" "),a("p",[e._v("持久节点（PERSISTENT）")]),e._v(" "),a("blockquote",[a("p",[e._v("这类节点被创建后，就会一直存在于Zk服务器上。直到手动删除。")])]),e._v(" "),a("p",[e._v("持久顺序节点（PERSISTENT_SEQUENTIAL）")]),e._v(" "),a("blockquote",[a("p",[e._v("它的基本特性同持久节点，不同在于增加了顺序性。父节点会维护一个自增整性数字，用于子节点的创建的先后顺序。")])]),e._v(" "),a("p",[e._v("临时节点（EPHEMERAL）")]),e._v(" "),a("blockquote",[a("p",[e._v("临时节点的生命周期与客户端的会话绑定，一旦客户端会话失效（非TCP连接断开），那么这个节点就会被自动清理掉。zk规定临时节点只能作为叶子节点。")])]),e._v(" "),a("p",[e._v("临时顺序节点（EPHEMERAL_SEQUENTIAL）")]),e._v(" "),a("blockquote",[a("p",[e._v("基本特性同临时节点，添加了顺序的特性。")])]),e._v(" "),a("h1",{attrs:{id:"znode存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#znode存储"}},[e._v("#")]),e._v(" znode存储")]),e._v(" "),a("p",[e._v("znode节点里面存储的是什么？")]),e._v(" "),a("p",[e._v("Znode数据节点的代码如下")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public class DataNode implements Record {\n    byte data[];                    \n    Long acl;                       \n    public StatPersisted stat;       \n    private Set<String> children = null; \n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("Znode包含了存储数据、访问权限、子节点引用、节点状态信息")]),e._v(" "),a("ul",[a("li",[e._v("data: znode存储的业务数据信息")]),e._v(" "),a("li",[e._v("ACL: 记录客户端对znode节点的访问权限，如IP等。")]),e._v(" "),a("li",[e._v("child: 当前节点的子节点引用")]),e._v(" "),a("li",[e._v("stat: 包含Znode节点的状态信息，比如事务id、版本号、时间戳等等。")])]),e._v(" "),a("p",[e._v("Q: 每个节点的数据最大不能超过多少?")]),e._v(" "),a("blockquote",[a("p",[e._v("为了保证高吞吐和低延迟，以及数据的一致性，znode只适合存储非常小的数据，不能超过1M，最好都小于1K。")])])])}),[],!1,null,null,null);t.default=_.exports}}]);