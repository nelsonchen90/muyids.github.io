(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{522:function(v,_,t){"use strict";t.r(_);var r=t(42),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流")]),v._v(" "),t("ul",[t("li",[v._v("缓存：缓存的目的是提升系统访问速度和增大系统处理容量")]),v._v(" "),t("li",[v._v("降级：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行")]),v._v(" "),t("li",[v._v("限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理")])]),v._v(" "),t("p",[v._v("常用限流算法：")]),v._v(" "),t("ul",[t("li",[v._v("计数器算法")]),v._v(" "),t("li",[v._v("滑动窗口")]),v._v(" "),t("li",[v._v("令牌桶算法")]),v._v(" "),t("li",[v._v("漏桶算法")])]),v._v(" "),t("h2",{attrs:{id:"计数器算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计数器算法"}},[v._v("#")]),v._v(" 计数器算法")]),v._v(" "),t("p",[v._v("计数器算法是限流算法里最简单也是最容易实现的一种算法。")]),v._v(" "),t("p",[v._v("比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter")]),v._v(" "),t("p",[v._v("计数器算法虽然简单，但是有一个十分致命的问题，那就是临界问题")]),v._v(" "),t("p",[v._v("假设有一个恶意用户，他在0:59时，瞬间发送了100个请求，并且1:00又瞬间发送了100个请求，那么其实这个用户在 1秒里面，瞬间发送了200个请求。我们刚才规定的是1分钟最多100个请求，也就是每秒钟最多1.7个请求，用户通过在时间窗口的重置节点处突发请求， 可以瞬间超过我们的速率限制。用户有可能通过算法的这个漏洞，瞬间压垮我们的应用。")]),v._v(" "),t("p",[v._v("聪明的朋友可能已经看出来了，刚才的问题其实是因为我们统计的精度太低。那么如何很好地处理这个问题呢？或者说，如何将临界问题的影响降低呢？我们可以看下面的滑动窗口算法。")]),v._v(" "),t("h2",{attrs:{id:"滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[v._v("#")]),v._v(" 滑动窗口")]),v._v(" "),t("p",[v._v("滑动窗口，又称rolling window。为了解决这个问题，我们引入了滑动窗口算法。如果学过TCP网络协议的话，那么一定对滑动窗口这个名词不会陌生")]),v._v(" "),t("p",[v._v("比如一个时间窗口就是一分钟, 然后我们将时间窗口进行划分，将滑动窗口划成了6格，所以每格代表的是10秒钟。每过10秒钟，我们的时间窗口就会往右滑动一格。每一个格子都有自己独立的计数器counter，比如当一个请求 在0:35秒的时候到达，那么0:30~0:39对应的counter就会加1。")]),v._v(" "),t("p",[v._v("我们可以发现，计数器算法其实就是滑动窗口算法。只是它没有对时间窗口做进一步地划分，所以只有1格。")]),v._v(" "),t("p",[v._v("由此可见，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。")]),v._v(" "),t("h2",{attrs:{id:"令牌桶算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#令牌桶算法"}},[v._v("#")]),v._v(" 令牌桶算法")]),v._v(" "),t("p",[v._v("令牌桶算法是比较常见的限流算法之一，大概描述如下：")]),v._v(" "),t("ol",[t("li",[v._v("所有的请求在处理之前都需要拿到一个可用的令牌才会被处理；")]),v._v(" "),t("li",[v._v("根据限流大小，设置按照一定的速率往桶里添加令牌；")]),v._v(" "),t("li",[v._v("桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝；")]),v._v(" "),t("li",[v._v("请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除；")]),v._v(" "),t("li",[v._v("令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流；")])]),v._v(" "),t("h2",{attrs:{id:"漏桶算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#漏桶算法"}},[v._v("#")]),v._v(" 漏桶算法")]),v._v(" "),t("p",[v._v("漏桶算法其实很简单，可以粗略的认为就是注水漏水过程，往桶中以一定速率流出水，以任意速率流入水，当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。")])])}),[],!1,null,null,null);_.default=a.exports}}]);