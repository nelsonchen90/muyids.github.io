(window.webpackJsonp=window.webpackJsonp||[]).push([[171],{416:function(t,o,v){"use strict";v.r(o);var r=v(42),_=Object(r.a)({},(function(){var t=this,o=t.$createElement,v=t._self._c||o;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"分区原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分区原因"}},[t._v("#")]),t._v(" 分区原因")]),t._v(" "),v("ol",[v("li",[t._v("方便在集群中扩展，每个 Partition 可以通过调整以适应它所在的机器，而一个 topic\n又可以有多个 Partition 组成，因此整个集群就可以适应任意大小的数据了")]),t._v(" "),v("li",[t._v("提高并发，可以以 Partition 为单位读写")])]),t._v(" "),v("h1",{attrs:{id:"分区原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分区原则"}},[t._v("#")]),t._v(" 分区原则")]),t._v(" "),v("p",[t._v("将 producer 发送的数据封装成一个"),v("code",[t._v("ProducerRecord")]),t._v("对象。")]),t._v(" "),v("p",[t._v("ProducerRecord对象的构造方法：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://muyids.oss-cn-beijing.aliyuncs.com/kafka-java-ProducerRecord.png",alt:"ProducerRecord"}})]),t._v(" "),v("ol",[v("li",[t._v("指明"),v("code",[t._v("partition")]),t._v("，直接使用")]),t._v(" "),v("li",[t._v("没有"),v("code",[t._v("partition")]),t._v("，指定了"),v("code",[t._v("key")]),t._v("的情况，将"),v("code",[t._v("key")]),t._v("的hash值与"),v("code",[t._v("topic")]),t._v("的"),v("code",[t._v("partition")]),t._v("数进行取余得到"),v("code",[t._v("partition")]),t._v("的值")]),t._v(" "),v("li",[t._v("既没有"),v("code",[t._v("partition")]),t._v("又没有"),v("code",[t._v("key")]),t._v("的情况，第一次随机生成一个整数，后面自增，然后与"),v("code",[t._v("topic")]),t._v("可用的"),v("code",[t._v("partition")]),t._v("总数取余得到"),v("code",[t._v("partition")]),t._v("的值，也就是 "),v("code",[t._v("round-robin")]),t._v(" 算法")])])])}),[],!1,null,null,null);o.default=_.exports}}]);