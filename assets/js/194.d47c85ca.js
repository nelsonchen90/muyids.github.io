(window.webpackJsonp=window.webpackJsonp||[]).push([[194],{369:function(v,_,t){"use strict";t.r(_);var s=t(42),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("一致性问题是分布式常见问题，还可以再分为"),t("strong",[v._v("最终一致性")]),v._v("和"),t("strong",[v._v("强一致性")]),v._v("。")]),v._v(" "),t("p",[v._v("一致性问题不可避免，"),t("strong",[v._v("数据库和缓存双写，就必然会存在不一致的问题")]),v._v("。")]),v._v(" "),t("p",[v._v("答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。")]),v._v(" "),t("p",[v._v("另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，"),t("strong",[v._v("有强一致性要求的数据，不能放缓存")]),v._v("。")]),v._v(" "),t("p",[v._v("回答：首先，采取正确更新策略，做两步操作："),t("strong",[v._v("删缓存")]),v._v("和"),t("strong",[v._v("更新数据库")]),v._v("。")]),v._v(" "),t("p",[v._v("但是这两步操作也是有问题的；不管是先写数据库，再删除缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。（并发读写）")])]),v._v(" "),t("li",[t("p",[v._v("如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。（宕机）")])])]),v._v(" "),t("h2",{attrs:{id:"如何解决上面两步出现的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何解决上面两步出现的问题"}},[v._v("#")]),v._v(" 如何解决上面两步出现的问题")]),v._v(" "),t("ol",[t("li",[v._v("延时双删策略")]),v._v(" "),t("li",[v._v("设置缓存的过期时间")])]),v._v(" "),t("h3",{attrs:{id:"延时双删策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#延时双删策略"}},[v._v("#")]),v._v(" 延时双删策略")]),v._v(" "),t("p",[v._v("在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。具体步骤是：")]),v._v(" "),t("ol",[t("li",[v._v("先删除缓存")]),v._v(" "),t("li",[v._v("再写数据库")]),v._v(" "),t("li",[v._v("休眠500毫秒（根据具体的业务时间来定）")]),v._v(" "),t("li",[v._v("再次删除缓存。")])]),v._v(" "),t("p",[v._v("那么，这个500毫秒怎么确定的，具体该休眠多久呢？")]),v._v(" "),t("p",[v._v("需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。")]),v._v(" "),t("p",[v._v("当然，这种策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。")]),v._v(" "),t("h3",{attrs:{id:"设置缓存的过期时间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置缓存的过期时间"}},[v._v("#")]),v._v(" 设置缓存的过期时间")]),v._v(" "),t("p",[v._v("从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存")]),v._v(" "),t("p",[v._v("结合"),t("strong",[v._v("延时双删策略+缓存超时设置")]),v._v("，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。")])])}),[],!1,null,null,null);_.default=r.exports}}]);