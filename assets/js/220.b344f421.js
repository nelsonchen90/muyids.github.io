(window.webpackJsonp=window.webpackJsonp||[]).push([[220],{388:function(v,_,e){"use strict";e.r(_);var t=e(42),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("设计一个短网址系统(将 长网址 转换成 短网址，方便用户使用url）")]),v._v(" "),e("p",[v._v("4S分析法")]),v._v(" "),e("ol",[e("li",[v._v("提问：分析场景，功能，QPS，存储空间 -- Scenario")]),v._v(" "),e("li",[v._v("画图：根据分析结果设计“可行解” -- Service + Storage")]),v._v(" "),e("li",[v._v("进化：研究可能遇到的问题，优化系统 -- Scale")])]),v._v(" "),e("p",[v._v("场景分析")]),v._v(" "),e("ol",[e("li",[v._v("把长网址 转换为 短网址")]),v._v(" "),e("li",[v._v("把短网址 还原为 长网址（给用户，用户通过短网址），并跳转")])]),v._v(" "),e("h2",{attrs:{id:"场景分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景分析"}},[v._v("#")]),v._v(" 场景分析")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("询问日活用户量")]),v._v(" "),e("p",[v._v("微博约100M")])]),v._v(" "),e("li",[e("p",[v._v("推算产生一条Tiny Url的QPS")]),v._v(" "),e("p",[v._v("假定每个用户每天发0.1条带Url的微博")]),v._v(" "),e("p",[v._v("Average Write QPS = 100 M * 0.1 / 86400 -> 115 QPS\n峰值Peak Wirte QPS = 125 * （2 ~ 5） -> 200 ~ 500（考虑到明星结婚之类的新闻，峰值可能更高）")])]),v._v(" "),e("li",[e("p",[v._v("推算点击一条Tiny Url的QPS")]),v._v(" "),e("p",[v._v("假设平均每个用户每天点击1个Tiny Url\nAvearge Read QPS = 100 M * 1 / 86400 ~= 1K\nPeak Read QPS ~= 2K ~ 5K")])]),v._v(" "),e("li",[e("p",[v._v("推算存储空间")]),v._v(" "),e("p",[v._v("每天产生的url数量 100 M * 0.1 ~= 10M条\n每一条url假设100bytes, 100 bytes * 10M条 = 1000 M bytes = 1 G\n1T的硬盘可以用3年")])])]),v._v(" "),e("h2",{attrs:{id:"服务分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务分析"}},[v._v("#")]),v._v(" 服务分析")]),v._v(" "),e("p",[v._v("服务比较简单，只需要设计一个UrlService Application")]),v._v(" "),e("p",[v._v("函数设计")]),v._v(" "),e("ul",[e("li",[v._v("UrlService.encode(long_url)")]),v._v(" "),e("li",[v._v("UrlService.decode(short_url)")])]),v._v(" "),e("p",[v._v("API设计")]),v._v(" "),e("p",[v._v("GET /${short_url}")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[v._v("if （not existed) return 404\nreturn a Http redirect response\n")])])]),e("p",[v._v("POST  /data/shorten/")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[v._v("Data = {url: http://xxxxlonglong..}\nreturn shorten url\n")])])]),e("h2",{attrs:{id:"算法设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法设计"}},[v._v("#")]),v._v(" 算法设计")]),v._v(" "),e("p",[v._v("encode和decode")]),v._v(" "),e("p",[v._v("算法1：使用哈希函数（不可行）")]),v._v(" "),e("p",[v._v("比如取Long Url的MD5的后6位\n优点：快\n缺点：很难设计一个没有冲突的哈希算法")]),v._v(" "),e("p",[v._v("算法2：随机生成+数据库比较去重")]),v._v(" "),e("p",[v._v("随机生成一个6位的short url，如果没有被用过，就绑定到Long Url")]),v._v(" "),e("p",[v._v("优点: 实现简单\n缺点：生成短网址的速度会随着短网址越来越多变得越来越慢")]),v._v(" "),e("p",[v._v("算法3：进制转换")]),v._v(" "),e("p",[v._v("short url的组成字符包括0-9，a-z, A-Z,共62个，把短网址字符串看做一个62进制的数字\n每次发起生成请求，进制数+1")]),v._v(" "),e("p",[v._v("优点：效率高\n缺点：依赖于全局自增的ID")]),v._v(" "),e("h2",{attrs:{id:"存储"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[v._v("#")]),v._v(" 存储")]),v._v(" "),e("p",[v._v("是否需要支持Transaction?  不需要 nosql +1")]),v._v(" "),e("p",[v._v("是否需要丰富的SQLQuery? 不需要 nosql +1")]),v._v(" "),e("p",[v._v("代码量，是否想偷懒？")]),v._v(" "),e("blockquote",[e("p",[v._v("大多数Web Framework和SQL数据库兼容得很好\n用sql比用NOSQL少写很多代码（nodejs配合nosql代码量也很少）")])]),v._v(" "),e("p",[v._v("对QPS的要求有多高？ NOSQL的QPS更高")]),v._v(" "),e("p",[v._v("对Scalability的要求多高？")]),v._v(" "),e("blockquote",[e("p",[v._v("SQL 需要码农自己写代码来Scale")])]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[v._v("TODO DB如何做Sharding, Replica\n")])])]),e("blockquote",[e("p",[v._v("NOSQL自动Sharding, Replica")])]),v._v(" "),e("p",[v._v("是否需要Sequential ID?自增ID ？ -- 取决于算法是什么")]),v._v(" "),e("h2",{attrs:{id:"scale-扩展-优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scale-扩展-优化"}},[v._v("#")]),v._v(" Scale 扩展&优化")]),v._v(" "),e("p",[v._v("如何加快响应速度？")]),v._v(" "),e("blockquote",[e("p",[v._v("优化服务器访问速度：不同地区使用不同的web服务器，通过DNS解析不同地区的用户到不同的服务器\n优化数据访问速度：中心化的Mysql+Distributed Membcached;不同地区做缓存，共享同一个数据库")])]),v._v(" "),e("p",[v._v("数据是否需要长久保存short Url？比如一年以上没有访问的，是否可以记录最近访问时间，定期删除")]),v._v(" "),e("p",[v._v("数据库扩展：写操作忙不过来，比如有的人用脚本写")]),v._v(" "),e("blockquote",[e("p",[v._v("表结构足够简单；不能垂直扩展，只能水平扩展；比如三台db;\n读操作可以用short mod 3 得到在哪台机器，直接去读\n写操作 long -> short 可以是一对多的关系，每请求一次写，生成一条数据;")])]),v._v(" "),e("h2",{attrs:{id:"一致性哈希算法（consistent-hashing）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一致性哈希算法（consistent-hashing）"}},[v._v("#")]),v._v(" 一致性哈希算法（Consistent Hashing）")]),v._v(" "),e("p",[v._v("水平扩展(Horizontal Sharding)的终极武器")]),v._v(" "),e("ul",[e("li",[v._v("水平切分(Horizontal Sharding)：同一张表，比如交易等，划分在不同的机器上")]),v._v(" "),e("li",[v._v("垂直切分（vertical sharding）: 不同的表放在不同的机器上")])]),v._v(" "),e("p",[v._v("不一致性哈希的缺点：")]),v._v(" "),e("p",[v._v("当取模的底数发生改变时，大部分数据 会发生迁移")]),v._v(" "),e("p",[v._v("简单的一致性哈希算法：")]),v._v(" "),e("ul",[e("li",[v._v("取模的底数取一个很大的数，比如360")]),v._v(" "),e("li",[v._v("将360分配给n台机器，每台机器负责一段区间")]),v._v(" "),e("li",[v._v("区间分配信息记录在一张表，存在web server上")]),v._v(" "),e("li",[v._v("每次增删改查数据，先查询区间分配表，再操作")]),v._v(" "),e("li",[v._v("新增机器时，查询区间和最大的两台机器，分成三台")])]),v._v(" "),e("p",[v._v("缺陷：")]),v._v(" "),e("ol",[e("li",[v._v("数据分布不均匀；")]),v._v(" "),e("li",[v._v("迁移压力大；新机器的数据只能从两台老机器上获取，导致两台老机器负载压力大")])]),v._v(" "),e("p",[v._v("更实用的一致性哈希")]),v._v(" "),e("ul",[e("li",[v._v("将整个hash区间看做环，环的大小为2^64-1")]),v._v(" "),e("li",[v._v("将机器和数据都看做环上的点")]),v._v(" "),e("li",[v._v("引入虚节点的概念")])])])}),[],!1,null,null,null);_.default=r.exports}}]);