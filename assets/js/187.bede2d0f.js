(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{383:function(t,a,_){"use strict";_.r(a);var v=_(42),s=Object(v.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"数据库命令规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库命令规范"}},[t._v("#")]),t._v(" 数据库命令规范")]),t._v(" "),_("ul",[_("li",[t._v("所有数据库对象名称必须使用小写字母并用下划线分割")]),t._v(" "),_("li",[t._v("所有数据库对象名称禁止使用mysql保留关键字\n（如果表名中包含关键字查询时，需要将其用单引号括起来）")]),t._v(" "),_("li",[t._v("数据库对象的命名要能做到见名识意，并且最后不要超过32个字符")]),t._v(" "),_("li",[t._v("临时库表必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀并以日期(时间戳)为后缀")]),t._v(" "),_("li",[t._v("所有存储相同数据的列名和列类型必须一致\n（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）")])]),t._v(" "),_("h1",{attrs:{id:"数据库基本设计规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库基本设计规范"}},[t._v("#")]),t._v(" 数据库基本设计规范")]),t._v(" "),_("h2",{attrs:{id:"所有表必须使用innodb存储引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#所有表必须使用innodb存储引擎"}},[t._v("#")]),t._v(" 所有表必须使用Innodb存储引擎")]),t._v(" "),_("p",[t._v("没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎（mysql5.5之前默认使用Myisam，5.6以后默认的为Innodb）Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好")]),t._v(" "),_("h2",{attrs:{id:"数据库和表的字符集统一使用utf8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库和表的字符集统一使用utf8"}},[t._v("#")]),t._v(" 数据库和表的字符集统一使用UTF8")]),t._v(" "),_("p",[t._v("兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效")]),t._v(" "),_("h2",{attrs:{id:"所有表和字段都需要添加注释"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#所有表和字段都需要添加注释"}},[t._v("#")]),t._v(" 所有表和字段都需要添加注释")]),t._v(" "),_("p",[t._v("使用comment从句添加表和列的备注 从一开始就进行数据字典的维护")]),t._v(" "),_("h2",{attrs:{id:"尽量控制单表数据量的大小，建议控制在500万以内"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽量控制单表数据量的大小，建议控制在500万以内"}},[t._v("#")]),t._v(" 尽量控制单表数据量的大小，建议控制在500万以内")]),t._v(" "),_("p",[t._v("500万并不是MySQL数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小")]),t._v(" "),_("h2",{attrs:{id:"谨慎使用mysql分区表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#谨慎使用mysql分区表"}},[t._v("#")]),t._v(" 谨慎使用MySQL分区表")]),t._v(" "),_("p",[t._v("分区表在物理上表现为多个文件，在逻辑上表现为一个表\n谨慎选择分区键，跨分区查询效率可能更低\n建议采用物理分表的方式管理大数据")]),t._v(" "),_("h2",{attrs:{id:"尽量做到冷热数据分离，减小表的宽度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽量做到冷热数据分离，减小表的宽度"}},[t._v("#")]),t._v(" 尽量做到冷热数据分离，减小表的宽度")]),t._v(" "),_("p",[t._v("MySQL限制每个表最多存储4096列，并且每一行数据的大小不能超过65535字节 减少磁盘IO,保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的IO） 更有效的利用缓存，避免读入无用的冷数据 经常一起使用的列放到一个表中（避免更多的关联操作）")]),t._v(" "),_("h2",{attrs:{id:"禁止在表中建立预留字段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#禁止在表中建立预留字段"}},[t._v("#")]),t._v(" 禁止在表中建立预留字段")]),t._v(" "),_("p",[t._v("预留字段的命名很难做到见名识义\n预留字段无法确认存储的数据类型，所以无法选择合适的类型\n对预留字段类型的修改，会对表进行锁定")]),t._v(" "),_("h2",{attrs:{id:"禁止在数据库中存储图片，文件等大的二进制数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#禁止在数据库中存储图片，文件等大的二进制数据"}},[t._v("#")]),t._v(" 禁止在数据库中存储图片，文件等大的二进制数据")]),t._v(" "),_("p",[t._v("通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时 通常存储于文件服务器，数据库只存储文件地址信息")]),t._v(" "),_("h2",{attrs:{id:"禁止在线上做数据库压力测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#禁止在线上做数据库压力测试"}},[t._v("#")]),t._v(" 禁止在线上做数据库压力测试")]),t._v(" "),_("h2",{attrs:{id:"禁止从开发环境，测试环境直接连接生成环境数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#禁止从开发环境，测试环境直接连接生成环境数据库"}},[t._v("#")]),t._v(" 禁止从开发环境，测试环境直接连接生成环境数据库")]),t._v(" "),_("h1",{attrs:{id:"数据库字段设计规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库字段设计规范"}},[t._v("#")]),t._v(" 数据库字段设计规范")]),t._v(" "),_("h2",{attrs:{id:"优先选择符合存储需要的最小的数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优先选择符合存储需要的最小的数据类型"}},[t._v("#")]),t._v(" 优先选择符合存储需要的最小的数据类型")]),t._v(" "),_("h3",{attrs:{id:"原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),_("p",[t._v("列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少\n在遍历时所需要的IO次数也就越多， 索引的性能也就越差")]),t._v(" "),_("h3",{attrs:{id:"方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),_("ul",[_("li",[t._v("将字符串转换成数字类型存储，如：将IP地址转换成整形数据。")]),t._v(" "),_("li",[t._v("对于非负型的数据（如自增ID、整型IP）来说，要优先使用无符号整型来存储")])]),t._v(" "),_("h2",{attrs:{id:"避免使用text、blob数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免使用text、blob数据类型"}},[t._v("#")]),t._v(" 避免使用TEXT、BLOB数据类型")]),t._v(" "),_("p",[t._v("最常见的TEXT类型可以存储64k的数据")]),t._v(" "),_("ul",[_("li",[t._v("建议把BLOB或是TEXT列分离到单独的扩展表中")]),t._v(" "),_("li",[t._v("TEXT或BLOB类型只能使用前缀索引")])]),t._v(" "),_("h2",{attrs:{id:"避免使用enum类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免使用enum类型"}},[t._v("#")]),t._v(" 避免使用ENUM类型")]),t._v(" "),_("ul",[_("li",[t._v("修改ENUM值需要使用ALTER语句")]),t._v(" "),_("li",[t._v("ENUM类型的ORDER BY操作效率低，需要额外操作")]),t._v(" "),_("li",[t._v("禁止使用数值作为ENUM的枚举值")])]),t._v(" "),_("h2",{attrs:{id:"尽可能把所有列定义为not-null"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#尽可能把所有列定义为not-null"}},[t._v("#")]),t._v(" 尽可能把所有列定义为NOT NULL")]),t._v(" "),_("p",[t._v("原因：")]),t._v(" "),_("ul",[_("li",[t._v("索引NULL列需要额外的空间来保存，所以要占用更多的空间；")]),t._v(" "),_("li",[t._v("进行比较和计算时要对NULL值做特别的处理")])]),t._v(" "),_("h2",{attrs:{id:"使用timestamp（4个字节）或datetime类型（8个字节）存储时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用timestamp（4个字节）或datetime类型（8个字节）存储时间"}},[t._v("#")]),t._v(" 使用TIMESTAMP（4个字节）或DATETIME类型（8个字节）存储时间")]),t._v(" "),_("p",[t._v("TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。TIMESTAMP 占用4字节和INT相同，但比INT可读性高超出TIMESTAMP取值范围的使用DATETIME类型存储。\n经常会有人用字符串存储日期型的数据**（不正确的做法）**")]),t._v(" "),_("ul",[_("li",[t._v("缺点1：无法用日期函数进行计算和比较")]),t._v(" "),_("li",[t._v("缺点2：用字符串存储日期要占用更多的空间")])]),t._v(" "),_("h2",{attrs:{id:"同财务相关的金额类数据必须使用decimal类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同财务相关的金额类数据必须使用decimal类型"}},[t._v("#")]),t._v(" 同财务相关的金额类数据必须使用decimal类型")]),t._v(" "),_("ul",[_("li",[t._v("非精准浮点：float,double")]),t._v(" "),_("li",[t._v("精准浮点：decimal")])]),t._v(" "),_("p",[t._v("Decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。")]),t._v(" "),_("h2",{attrs:{id:"如何进行mysql的语句优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何进行mysql的语句优化"}},[t._v("#")]),t._v(" 如何进行mysql的语句优化")]),t._v(" "),_("ul",[_("li",[t._v("一看索引；")]),t._v(" "),_("li",[t._v("二看not，有not的话会导致索引无效，会强行全局搜索；")]),t._v(" "),_("li",[t._v("三看语句嵌套，嵌套太多了，人看着都费劲，机器看着也费劲")])]),t._v(" "),_("h2",{attrs:{id:"什么是sql注入（sql-injection）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是sql注入（sql-injection）"}},[t._v("#")]),t._v(" 什么是SQL注入（SQL Injection）")]),t._v(" "),_("p",[t._v("所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。")]),t._v(" "),_("p",[t._v("在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。")]),t._v(" "),_("h2",{attrs:{id:"分库分表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[t._v("#")]),t._v(" 分库分表")]),t._v(" "),_("p",[t._v("当mysql数据库单表数据量破千万以后，MySQL性能将下降厉害，并且随着业务的规模化，单表将很难抗住并发压力，出现故障后恢复时间变长对业务影响也会变大，因此需要考虑数据水平扩展。")]),t._v(" "),_("p",[t._v("想水平扩展，就需要分库分表的支持，分库分表这四个字说起来很容易，按照id取模将数据打散分摊压力，但是干完这些之后需要解决由此带来的问题，这些很难：")]),t._v(" "),_("ol",[_("li",[t._v("事务支持，扩库/扩表后事务就成分布式的了，问题难度显然上升了一个级别")]),t._v(" "),_("li",[t._v("查询结果合并，这个看起来不难，但是把order by/limit/查询中不带分表字段等加上，要解决的问题还也不少")]),t._v(" "),_("li",[t._v("join，这个更难")]),t._v(" "),_("li",[t._v("分库？分表？还是分库分表？这个需要考虑并做一个决定")]),t._v(" "),_("li",[t._v("分完后能否合并？分容易，和很难")]),t._v(" "),_("li",[t._v("。。。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);