(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{462:function(t,a,e){"use strict";e.r(a);var _=e(42),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文档"}},[t._v("#")]),t._v(" 文档")]),t._v(" "),e("p",[t._v("在Elasticsearch中，文档以JSON格式进行存储，可以是复杂的结构")]),t._v(" "),e("h3",{attrs:{id:"元数据（metadata）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元数据（metadata）"}},[t._v("#")]),t._v(" 元数据（metadata）")]),t._v(" "),e("p",[t._v("一个文档不只有数据。它还包含了元数据(metadata)——关于文档的信息。三个必须的元数据节点是：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("节点")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("说明")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("_index")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("文档存储的地方")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("_type")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("文档代表的对象的类")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("_id")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("文档的唯一标识")])])])]),t._v(" "),e("h3",{attrs:{id:"index"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#index"}},[t._v("#")]),t._v(" _index")]),t._v(" "),e("p",[t._v("**索引(index)**类似于关系型数据库里的“数据库”——它是我们存储和索引关联数据的地方。")]),t._v(" "),e("p",[t._v("事实上，我们的数据被存储和索引在**分片(shards)**中，索引只是一个把一个或多个分片分组在一起的逻辑空\n间。然而，这只是一些内部细节——我们的程序完全不用关心分片。对于我们的程序而言，文档存储在索引\n(index)中。剩下的细节由Elasticsearch关心既可。")]),t._v(" "),e("h3",{attrs:{id:"type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#type"}},[t._v("#")]),t._v(" _type")]),t._v(" "),e("p",[t._v("在应用中，我们使用对象表示一些“事物”，例如一个用户、一篇博客、一个评论，或者一封邮件。每个对象都属于一\n个"),e("strong",[t._v("类(class)")]),t._v("，这个类定义了属性或与对象关联的数据。 user 类的对象可能包含姓名、性别、年龄和Email地址。")]),t._v(" "),e("p",[t._v("在关系型数据库中，我们经常将相同类的对象存储在一个表里，因为它们有着相同的结构。同理，在Elasticsearch\n中，我们使用相同**类型(type)**的文档表示相同的“事物”，因为他们的数据结构也是相同的。")]),t._v(" "),e("p",[t._v("每个**类型(type)"),e("strong",[t._v("都有自己的")]),t._v("映射(mapping)"),e("strong",[t._v("或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储\n在同一个索引下，但是类型的")]),t._v("映射(mapping)**会告诉Elasticsearch不同的文档如何被索引。")]),t._v(" "),e("p",[t._v("_type 的名字可以是大写或小写，不能包含下划线或逗号。我们将使用 blog 做为类型名。")]),t._v(" "),e("h3",{attrs:{id:"id"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#id"}},[t._v("#")]),t._v(" _id")]),t._v(" "),e("p",[e("strong",[t._v("id")]),t._v("仅仅是一个字符串，它与 "),e("strong",[t._v("_index")]),t._v(" 和 "),e("strong",[t._v("_type")]),t._v(" 组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文\n档，你可以自定义 _id ，也可以让Elasticsearch帮你自动生成（32位长度）。")]),t._v(" "),e("h2",{attrs:{id:"查询响应"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查询响应"}},[t._v("#")]),t._v(" 查询响应")]),t._v(" "),e("p",[t._v("TODO")])])}),[],!1,null,null,null);a.default=s.exports}}]);