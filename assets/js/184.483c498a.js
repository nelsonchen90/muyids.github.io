(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{389:function(v,_,t){"use strict";t.r(_);var a=t(42),i=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"是事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#是事务"}},[v._v("#")]),v._v(" 是事务")]),v._v(" "),t("p",[v._v("事务是一系列的操作,他们要符合ACID特性")]),v._v(" "),t("p",[v._v("最常见的理解就是:事务中的操作要么全部成功,要么全部失败")]),v._v(" "),t("p",[v._v("事务的四大特征ACID")]),v._v(" "),t("ul",[t("li",[v._v("原子性（Atomicity)\n要么全部成功,要么全部失败.不可能只执行一部分操作.")]),v._v(" "),t("li",[v._v("一致性（Consistency）\n系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.")]),v._v(" "),t("li",[v._v("隔离性（Isolation）\n通常来说:一个事务在完全提交之前,对其他事务是不可见的.也有例外情况")]),v._v(" "),t("li",[v._v("持久性（Durability）\n一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果.")])]),v._v(" "),t("h2",{attrs:{id:"同时有多个事务在进行会怎么样呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同时有多个事务在进行会怎么样呢"}},[v._v("#")]),v._v(" 同时有多个事务在进行会怎么样呢")]),v._v(" "),t("p",[v._v("多事务的并发进行一般会造成以下几个问题:")]),v._v(" "),t("ul",[t("li",[v._v("脏读: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚.")]),v._v(" "),t("li",[v._v("不可重复读: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作.")]),v._v(" "),t("li",[v._v('幻读: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成"幻觉".')])]),v._v(" "),t("h2",{attrs:{id:"mysql的事务隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql的事务隔离级别"}},[v._v("#")]),v._v(" MySQL的事务隔离级别")]),v._v(" "),t("p",[v._v("MySQL的四种隔离级别如下:")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("未提交读(READ UNCOMMITTED)")]),v._v(" "),t("p",[v._v("这就是上面所说的例外情况了,这个隔离级别下,其他事务可以看到本事务没有提交的部分修改.因此会造成脏读的问题(读取到了其他事务未提交的部分,而之后该事务进行了回滚).")]),v._v(" "),t("p",[v._v("这个级别的性能没有足够大的优势,但是又有很多的问题,因此很少使用.")])]),v._v(" "),t("li",[t("p",[v._v("已提交读(READ COMMITTED)")]),v._v(" "),t("p",[v._v("其他事务只能读取到本事务已经提交的部分.这个隔离级别有 不可重复读的问题,在同一个事务内的两次读取,拿到的结果竟然不一样,因为另外一个事务对数据进行了修改.")])]),v._v(" "),t("li",[t("p",[v._v("REPEATABLE READ(可重复读)\n可重复读隔离级别解决了上面不可重复读的问题(看名字也知道),但是仍然有一个新问题,就是 幻读,当你读取id> 10 的数据行时,对涉及到的所有行加上了读锁,此时例外一个事务新插入了一条id=11的数据,因为是新插入的,所以不会触发上面的锁的排斥,那么进行本事务进行下一次的查询时会发现有一条id=11的数据,而上次的查询操作并没有获取到,再进行插入就会有主键冲突的问题.")])]),v._v(" "),t("li",[t("p",[v._v("SERIALIZABLE(可串行化)")]),v._v(" "),t("p",[v._v("这是最高的隔离级别,可以解决上面提到的所有问题,因为他强制将所以的操作串行执行,这会导致并发性能极速下降,因此也不是很常用.")])])]),v._v(" "),t("h2",{attrs:{id:"innodb使用的是哪种隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#innodb使用的是哪种隔离级别"}},[v._v("#")]),v._v(" Innodb使用的是哪种隔离级别")]),v._v(" "),t("p",[v._v("InnoDB默认使用的是可重复读隔离级别.")])])}),[],!1,null,null,null);_.default=i.exports}}]);