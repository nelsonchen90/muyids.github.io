(window.webpackJsonp=window.webpackJsonp||[]).push([[175],{407:function(e,a,r){"use strict";r.r(a);var o=r(42),v=Object(o.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Kafka中都有哪些选举机制")]),e._v(" "),r("h1",{attrs:{id:"控制器的选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#控制器的选举"}},[e._v("#")]),e._v(" 控制器的选举")]),e._v(" "),r("p",[e._v("在Kafka集群中会有一个或多个broker，其中有一个broker会被选举为控制器（"),r("code",[e._v("Kafka Controller")]),e._v("），它负责管理整个集群中所有分区和副本的状态等工作。比如当某个分区的"),r("code",[e._v("leader")]),e._v("副本出现故障时，由控制器负责为该分区选举新的leader副本。再比如当检测到某个分区的"),r("code",[e._v("ISR")]),e._v("集合发生变化时，由控制器负责通知所有"),r("code",[e._v("broker")]),e._v("更新其元数据信息。")]),e._v(" "),r("p",[r("code",[e._v("Kafka Controller")]),e._v("的选举是依赖"),r("code",[e._v("Zookeeper")]),e._v("来实现的，在Kafka集群中"),r("strong",[e._v("哪个broker能够成功创建/controller这个临时（EPHEMERAL）节点他就可以成为Kafka Controller")]),e._v("。")]),e._v(" "),r("h1",{attrs:{id:"分区leader的选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分区leader的选举"}},[e._v("#")]),e._v(" 分区leader的选举")]),e._v(" "),r("p",[e._v("Kafka将每个Topic进行分区Patition，以提高消息的并行处理，同时为保证高可用性，每个分区都有一定数量的副本 Replica，这样当部分服务器不可用时副本所在服务器就可以接替上来，保证系统可用性。")]),e._v(" "),r("p",[e._v("在Leader上负责读写，Follower负责数据的同步。"),r("strong",[e._v("当一个Leader发生故障如何从Follower中选择新Leader呢？")])]),e._v(" "),r("p",[e._v("Kafka在Zookeeper上针对每个Topic都维护了一个ISR（"),r("code",[e._v("in-sync replica")]),e._v("--已同步的副本）的集合，集合的增减Kafka都会更新该记录。")]),e._v(" "),r("p",[e._v("如果某分区的Leader不可用，Kafka就从"),r("code",[e._v("ISR")]),e._v("集合中选择一个副本作为新的Leader。这样就可以容忍的失败数比较高，假如某Topic有N+1个副本，则可以容忍N个服务器不可用。")]),e._v(" "),r("p",[e._v("如果ISR中副本都不可用，有两种处理方法：")]),e._v(" "),r("ol",[r("li",[e._v("等待ISR集合中副本复活后选择一个可用的副本；")]),e._v(" "),r("li",[e._v("选择集群中其他可用副本；")])]),e._v(" "),r("h1",{attrs:{id:"消费者相关的选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费者相关的选举"}},[e._v("#")]),e._v(" 消费者相关的选举")])])}),[],!1,null,null,null);a.default=v.exports}}]);