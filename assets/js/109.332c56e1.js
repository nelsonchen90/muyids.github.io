(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{540:function(v,_,t){"use strict";t.r(_);var e=t(42),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("操作系统有关知识点")]),v._v(" "),t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[v._v("#")]),v._v(" 目录")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B"}},[v._v("进程线程协程")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"}},[v._v("线程调度算法")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"}},[v._v("进程通信的方式")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"}},[v._v("页面置换算法")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#epoll%E4%B8%8Eselect"}},[v._v("epoll与select")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#%E6%AD%BB%E9%94%81"}},[v._v("死锁")])])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"进程线程协程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程线程协程"}},[v._v("#")]),v._v(" 进程线程协程")]),v._v(" "),t("ul",[t("li",[v._v("进程：资源分配的最小单位；操作系统会以进程为单位，分配系统资源（CPU时间片、堆内存等资源）")]),v._v(" "),t("li",[v._v("线程：有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位")]),v._v(" "),t("li",[v._v("协程：是由程序所控制，在用户态执行，是一种比线程更加轻量级的存在")])]),v._v(" "),t("h2",{attrs:{id:"线程调度算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程调度算法"}},[v._v("#")]),v._v(" 线程调度算法")]),v._v(" "),t("p",[v._v("cpu调度算法")]),v._v(" "),t("ol",[t("li",[v._v("先来先服务(FCFS)")]),v._v(" "),t("li",[v._v("最短作业优先（SJF）")]),v._v(" "),t("li",[v._v("基于优先权的调度算法（FPPS）")]),v._v(" "),t("li",[v._v("时间片轮转（RR）")]),v._v(" "),t("li",[v._v("多级队列调度（Multilevel feedback queue）")])]),v._v(" "),t("h2",{attrs:{id:"进程通信的方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程通信的方式"}},[v._v("#")]),v._v(" 进程通信的方式")]),v._v(" "),t("h2",{attrs:{id:"epoll与select"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#epoll与select"}},[v._v("#")]),v._v(" epoll与select")]),v._v(" "),t("p",[v._v("select基于轮询机制，epoll基于通知机制，直接通知发生IO事件的fd，select需要在内核去和用户去不断拷贝fd_set, epoll采用共享内存机制，不需要，epoll内核数据结构用的是红黑树，效率更高。")]),v._v(" "),t("h2",{attrs:{id:"死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[v._v("#")]),v._v(" 死锁")]),v._v(" "),t("p",[v._v("产生条件 避免死锁 解除死锁")]),v._v(" "),t("ol",[t("li",[v._v("多线程和多进程的区别（重点 必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）！")])]),v._v(" "),t("p",[v._v("1）进程数据是分开的:共享复杂，需要用IPC，同步简单；多线程共享进程数据：共享简单，同步复杂")]),v._v(" "),t("p",[v._v("2）进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快")]),v._v(" "),t("p",[v._v("3）进程占用内存多， CPU利用率低；线程占用内存少， CPU利用率高")]),v._v(" "),t("p",[v._v("4）进程编程简单，调试简单；线程 编程复杂，调试复杂")]),v._v(" "),t("p",[v._v("5）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉")]),v._v(" "),t("p",[v._v("6）进程适应于多核、多机分布；线程适用于多核")]),v._v(" "),t("p",[v._v("线程所私有的：")]),v._v(" "),t("p",[v._v("线程id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno变量")]),v._v(" "),t("p",[v._v("2. 多线程锁的种类有哪些？")]),v._v(" "),t("p",[v._v("a.互斥锁（mutex）b.递归锁 c.自旋锁 d.读写锁")]),v._v(" "),t("p",[v._v("3. 自旋锁和互斥锁的区别？")]),v._v(" "),t("p",[v._v("当锁被其他线程占用时，其他线程并不是睡眠状态，而是不停的消耗CPU，获取锁；互斥锁则不然，保持睡眠，直到互斥锁被释放激活。")]),v._v(" "),t("p",[v._v("自旋锁，递归调用容易造成死锁，对长时间才能获得到锁的情况，使用自旋锁容易造成CPU效率低，只有内核可抢占式或SMP情况下才真正需要自旋锁。")]),v._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[v._v("进程间通信和线程间通信")])]),v._v(" "),t("p",[v._v("1）.管道 2）消息队列 3)共享内存 4)信号量 5)套接字 6)条件变量")]),v._v(" "),t("p",[v._v("5.多线程程序架构，线程数量应该如何设置？")]),v._v(" "),t("p",[v._v("应尽量和CPU核数相等或者为CPU核数+1的个数")])])}),[],!1,null,null,null);_.default=a.exports}}]);