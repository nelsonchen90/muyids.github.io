(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{502:function(a,e,t){"use strict";t.r(e);var s=t(42),v=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("h3",{attrs:{id:"结构：数组-链表-红黑树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构：数组-链表-红黑树"}},[a._v("#")]),a._v(" 结构：数组+链表+红黑树")]),a._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("HashMap是基于hashing的原理，通过"),t("code",[a._v("put(k,v)")]),a._v("存储对象到HashMap中，通过get(k)方式获取对象。")]),a._v(" "),t("p",[a._v("当使用"),t("code",[a._v("put(k,v)")]),a._v("传递key、value的时候，首先调用"),t("code",[a._v("hashCode()")]),a._v("方法，计算bucket位置来存储Node对象。")]),a._v(" "),t("h4",{attrs:{id:"put-k-v-过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#put-k-v-过程"}},[a._v("#")]),a._v(" put(k,v)过程")]),a._v(" "),t("ol",[t("li",[a._v("对key求Hash值，计算下标。")]),a._v(" "),t("li",[a._v("如果没有碰撞存入桶中，碰撞则放入bucket的链表或者红黑树中。")]),a._v(" "),t("li",[a._v("如果链表超过阈值（默认链表数超过8，总Entry数超过64）则转换为红黑树，链表长度<6则转换回链表。")]),a._v(" "),t("li",[a._v("key结点存在则替换旧值。")]),a._v(" "),t("li",[a._v("如果桶满（容量*加载因子），就要resize（扩容2倍后重排）。")])]),a._v(" "),t("h3",{attrs:{id:"get-k-过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-k-过程"}},[a._v("#")]),a._v(" get(k)过程")]),a._v(" "),t("ol",[t("li",[a._v("首先将 key hash 之后取得所定位的桶。")]),a._v(" "),t("li",[a._v("如果桶为空则直接返回 null 。")]),a._v(" "),t("li",[a._v("否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。")]),a._v(" "),t("li",[a._v("如果第一个不匹配，则判断它的下一个是红黑树还是链表。")]),a._v(" "),t("li",[a._v("红黑树就按照树的查找方式返回值。不然就按照链表的方式遍历匹配返回值。")])]),a._v(" "),t("h3",{attrs:{id:"优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[a._v("#")]),a._v(" 优化")]),a._v(" "),t("p",[a._v("减少碰撞。原理是如果两个不相等的对象返回不同的 hashcode 的话，那么碰撞的几率就会小些。")]),a._v(" "),t("p",[a._v("这就意味着存链表结构减小，这样取值的话就不会频繁调用 equal 方法，从而提高 HashMap 的性能（扰动即 Hash 方法内部的算法实现，目的是让不同对象返回不同 hashcode）。")]),a._v(" "),t("p",[a._v("使用不可变的、声明作 final 对象，并且采用合适的 equals() 和 hashCode() 方法，将会减少碰撞的发生。")]),a._v(" "),t("h3",{attrs:{id:"多线程hashmap死循环问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程hashmap死循环问题"}},[a._v("#")]),a._v(" 多线程HashMap死循环问题")]),a._v(" "),t("p",[a._v("因为如果两个线程都发现 HashMap 需要重新调整大小了，它们会同时试着调整大小。\n在调整大小的过程中，存储在链表中的元素的次序会反过来。\n因为在resize过程中，移动到新的 bucket 位置的时候，HashMap 并不会将元素放在链表的尾部，而是放在头部，使用的是队头插入方法。\n这是为了避免尾部遍历（tail traversing）。如果条件竞争发生了，那么就死循环了，这也是导致CPU飙升的原因，所以多线程的环境下不使用 HashMap，而是使用"),t("code",[a._v("concurrentHashMap")]),a._v("。")]),a._v(" "),t("h2",{attrs:{id:"linkedhashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),t("p",[a._v("LinkedHashMap的实现就是HashMap+LinkedList的实现方式，以HashMap维护数据结构，以LinkList的方式维护数据插入顺序。\nLinkedHashMap通过维护一个运行所有条目的双向链表，LinkedHashMap保证了元素的迭代顺序。迭代顺序可以是插入顺序或者是访问顺序。")]),a._v(" "),t("h2",{attrs:{id:"treemap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),t("ul",[t("li",[a._v("是一个有序的key-value集合，它是通过红黑树实现的。")]),a._v(" "),t("li",[a._v("继承于AbstractMap，所以它是一个Map，即一个key-value集合。")]),a._v(" "),t("li",[a._v("实现了"),t("code",[a._v("NavigableMap")]),a._v("接口，意味着它支持一系列的导航方法。比如返回有序的key集合。")]),a._v(" "),t("li",[a._v("实现了"),t("code",[a._v("Cloneable")]),a._v("接口，意味着它能被克隆。")]),a._v(" "),t("li",[a._v("实现了"),t("code",[a._v("java.io.Serializable")]),a._v("接口，意味着它支持序列化。")]),a._v(" "),t("li",[a._v("基于"),t("code",[a._v("红黑树（Red-Black tree）")]),a._v("实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。")]),a._v(" "),t("li",[a._v("基本操作 "),t("code",[a._v("containsKey、get、put 和 remove")]),a._v(" 的时间复杂度是 log(n) 。")])]),a._v(" "),t("h2",{attrs:{id:"hashtable与hashmap的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable与hashmap的区别"}},[a._v("#")]),a._v(" HashTable与HashMap的区别")]),a._v(" "),t("ul",[t("li",[a._v("HashTable线程安全，HashMap线程不安全。")]),a._v(" "),t("li",[a._v("HashTable不可存储null值，HashMap可以存储null值。")]),a._v(" "),t("li",[a._v("HashMap去掉了HashTable的contains⽅方法，但是加上了 "),t("code",[a._v("containsValue()和containsKey()")]),a._v("方法。")])]),a._v(" "),t("h2",{attrs:{id:"concurrenthashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),t("h3",{attrs:{id:"结构：hashentry-红黑树-cas-synchronized"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构：hashentry-红黑树-cas-synchronized"}},[a._v("#")]),a._v(" 结构：HashEntry +红黑树+CAS+Synchronized")]),a._v(" "),t("h3",{attrs:{id:"数据结构：node（链表）、treenode（红黑树）、treebin（红黑树容器）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构：node（链表）、treenode（红黑树）、treebin（红黑树容器）"}},[a._v("#")]),a._v(" 数据结构：Node（链表）、TreeNode（红黑树）、TreeBin（红黑树容器）")]),a._v(" "),t("h3",{attrs:{id:"put-k-v-流程："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#put-k-v-流程："}},[a._v("#")]),a._v(" put(k,v)流程：")]),a._v(" "),t("ul",[t("li",[a._v("如果没有初始化就调用initTable()。")]),a._v(" "),t("li",[a._v("如果hash没有冲突就直接CAS插入。")]),a._v(" "),t("li",[a._v("如果还在进行扩容就继续扩容（多线程进行）。")]),a._v(" "),t("li",[a._v("如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入。")]),a._v(" "),t("li",[a._v("插入最后一个元素如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环。")]),a._v(" "),t("li",[a._v("如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容。")])]),a._v(" "),t("h3",{attrs:{id:"get-k-流程："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get-k-流程："}},[a._v("#")]),a._v(" get(k)流程：")]),a._v(" "),t("ul",[t("li",[a._v("计算hash值，定位到该table索引位置，如果是首节点符合就返回。")]),a._v(" "),t("li",[a._v("如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回。")]),a._v(" "),t("li",[a._v("以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null。")])])])}),[],!1,null,null,null);e.default=v.exports}}]);