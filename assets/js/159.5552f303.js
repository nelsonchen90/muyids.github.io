(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{440:function(r,t,a){"use strict";a.r(t);var s=a(42),e=Object(s.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"详细架构图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#详细架构图"}},[r._v("#")]),r._v(" 详细架构图")]),r._v(" "),a("p",[a("img",{attrs:{src:"https://muyids.oss-cn-beijing.aliyuncs.com/kafka-base-artichecture.png",alt:"kafka详细架构图"}})]),r._v(" "),a("h1",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[r._v("#")]),r._v(" 概念")]),r._v(" "),a("ul",[a("li",[r._v("Producer")]),r._v(" "),a("li",[r._v("Consumer")]),r._v(" "),a("li",[r._v("Consumer Group (CG)")]),r._v(" "),a("li",[r._v("Broker")]),r._v(" "),a("li",[r._v("Topic")]),r._v(" "),a("li",[r._v("Partition")]),r._v(" "),a("li",[r._v("Replica")]),r._v(" "),a("li",[r._v("Leader")]),r._v(" "),a("li",[r._v("Follower")]),r._v(" "),a("li",[r._v("Offset")])]),r._v(" "),a("h1",{attrs:{id:"producer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#producer"}},[r._v("#")]),r._v(" Producer")]),r._v(" "),a("p",[r._v("消息生产者，就是向 kafka broker 发消息的客户端;")]),r._v(" "),a("h1",{attrs:{id:"consumer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consumer"}},[r._v("#")]),r._v(" Consumer")]),r._v(" "),a("p",[r._v("消息消费者，向 kafka broker 取消息的客户端;")]),r._v(" "),a("h1",{attrs:{id:"topic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[r._v("#")]),r._v(" Topic")]),r._v(" "),a("p",[r._v("可以理解为一个队列;")]),r._v(" "),a("h1",{attrs:{id:"consumer-group-cg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consumer-group-cg"}},[r._v("#")]),r._v(" Consumer Group(CG)")]),r._v(" "),a("p",[r._v("kafka 用来实现一个 topic 消息的广播(发给所有的 consumer) 和单播(发给任意一个 consumer)的手段。")]),r._v(" "),a("p",[r._v("一个 topic 可以有多个 CG。")]),r._v(" "),a("p",[r._v("topic 的消息会复制 (不是真的复制，是概念上的)到所有的 CG，但每个 partion 只会把消息发给该 CG 中的一个 consumer。")]),r._v(" "),a("p",[r._v("如果需要实现广播，只要每个 consumer 有一个独立的 CG 就可以了。要实现 单播只要所有的 consumer 在同一个 CG。")]),r._v(" "),a("p",[r._v("用 CG 还可以将 consumer 进行自由的分组而不需要多次发送消息到不同的 topic;")]),r._v(" "),a("h1",{attrs:{id:"broker"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#broker"}},[r._v("#")]),r._v(" Broker")]),r._v(" "),a("p",[r._v("一台 kafka 服务器就是一个 broker。")]),r._v(" "),a("p",[r._v("一个集群由多个 broker 组成。")]),r._v(" "),a("p",[r._v("一个 broker 可以容纳多个 topic。")]),r._v(" "),a("h1",{attrs:{id:"partition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#partition"}},[r._v("#")]),r._v(" Partition")]),r._v(" "),a("p",[r._v("为了实现扩展性，一个非常大的 topic 可以分布到多个 broker(即服务器)上， 一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。")]),r._v(" "),a("p",[r._v("partition 中的每条消息 都会被分配一个有序的 id(offset)。")]),r._v(" "),a("p",[r._v("kafka 只保证按一个 partition 中的顺序将消息发给 consumer，不保证一个 topic 的整体(多个 partition 间)的顺序;")]),r._v(" "),a("h1",{attrs:{id:"offset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#offset"}},[r._v("#")]),r._v(" Offset")]),r._v(" "),a("p",[r._v("kafka 的存储文件都是按照 offset.kafka 来命名，用 offset 做名字的好处是方便查 找。")]),r._v(" "),a("p",[r._v("例如你想找位于 2049 的位置，只要找到 2048.kafka 的文件即可。当然 the first offset 就 是 00000000000.kafka。")])])}),[],!1,null,null,null);t.default=e.exports}}]);