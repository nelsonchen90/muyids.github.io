(window.webpackJsonp=window.webpackJsonp||[]).push([[229],{370:function(a,s,t){"use strict";t.r(s);var n=t(42),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"设计一个榜单"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个榜单"}},[a._v("#")]),a._v(" 设计一个榜单")]),a._v(" "),t("p",[a._v("基于redis有序集合实现")]),a._v(" "),t("p",[a._v("用到的API")]),a._v(" "),t("ul",[t("li",[a._v("zincrby")]),a._v(" "),t("li",[a._v("zrevrangewithscores")])]),a._v(" "),t("p",[a._v("多个榜单集成")]),a._v(" "),t("p",[a._v("zunionstore")]),a._v(" "),t("h2",{attrs:{id:"设计一个类微博"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个类微博"}},[a._v("#")]),a._v(" 设计一个类微博")]),a._v(" "),t("h2",{attrs:{id:"设计一个聊天系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个聊天系统"}},[a._v("#")]),a._v(" 设计一个聊天系统")]),a._v(" "),t("h2",{attrs:{id:"设计一个推送系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个推送系统"}},[a._v("#")]),a._v(" 设计一个推送系统")]),a._v(" "),t("p",[a._v("题目：一个推送场景，50 条内容，定时推送，先推 5%用户，\n一段时间后再找出效果最好的几条，推给所有用户。\n设计相关库表，系统模块, 需要可以落地，有伪代码")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("表结构")]),a._v(" "),t("p",[a._v("推送消息表 twitter")]),a._v(" "),t("p",[a._v('{\n"msg_id": "", // unique index\n""')]),a._v(" "),t("p",[a._v("}")]),a._v(" "),t("h2",{attrs:{id:"设计一个股票撮合交易系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个股票撮合交易系统"}},[a._v("#")]),a._v(" 设计一个股票撮合交易系统")]),a._v(" "),t("p",[a._v("最核心的一定是挂单交易核心模块 - 撮合交易")]),a._v(" "),t("p",[a._v("撮合交易的规则：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("买入价（A）必须大于或等于卖出价（B），即A>=B。")])]),a._v(" "),t("li",[t("p",[a._v("按价格优先、时间优先的原则进行。")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("当买入价大于卖出价时成交价应该如何确定？")])]),a._v(" "),t("p",[a._v("计算机在撮合时实际上是依据前一笔成交价而定出最新成交价的。如果前一笔成交价低于或等于卖出价，则最新成交价就是卖出价；如果前一笔成交价高于或等于买入价，则最新成交价就是买入价；如果前一笔成交价在卖出价与买入价之间，则最新成交价就是前一笔的成交价。下面不妨以例明之。")]),a._v(" "),t("p",[a._v("买方出价1399点，卖方出价是1397点。如果前一笔成交价为1397或1397点以下，最新成交价就是1397点；如果前一笔成交价为1399或1399点以上，则最新成交价就是1399点；如果前一笔成交价是1398点，则最新成交价就是1398点。")])])]),a._v(" "),t("p",[t("strong",[a._v("保证撮合交易在高并发场景下的稳定性")])]),a._v(" "),t("h2",{attrs:{id:"设计一个秒杀系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个秒杀系统"}},[a._v("#")]),a._v(" 设计一个秒杀系统")]),a._v(" "),t("h3",{attrs:{id:"需求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#需求"}},[a._v("#")]),a._v(" 需求")]),a._v(" "),t("p",[a._v("设计一个秒杀系统，支持百万级用户秒杀，不能超卖")]),a._v(" "),t("h3",{attrs:{id:"业务处理流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#业务处理流程"}},[a._v("#")]),a._v(" 业务处理流程")]),a._v(" "),t("p",[a._v("正常的一个业务处理流程")]),a._v(" "),t("ul",[t("li",[a._v("用户下单，生成订单")]),a._v(" "),t("li",[a._v("库存系统减库存")])]),a._v(" "),t("h3",{attrs:{id:"并发问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发问题"}},[a._v("#")]),a._v(" 并发问题")]),a._v(" "),t("h4",{attrs:{id:"前端限流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端限流"}},[a._v("#")]),a._v(" 前端限流")]),a._v(" "),t("p",[a._v("网关层直接过滤掉90%的请求")]),a._v(" "),t("h4",{attrs:{id:"优化缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化缓存"}},[a._v("#")]),a._v(" 优化缓存")]),a._v(" "),t("p",[a._v("查询库存时使用缓存；\n系统启动初始化时，同步数据库的库存到缓存；\n下单后，数据库减少成功后，同步缓存；")]),a._v(" "),t("h4",{attrs:{id:"优化数据库"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化数据库"}},[a._v("#")]),a._v(" 优化数据库")]),a._v(" "),t("ul",[t("li",[a._v("通过数据库乐观锁防止超卖")])]),a._v(" "),t("p",[a._v("update goods_table\nset count = count - 1\nwhere goods_id = xxxx & store > 0")]),a._v(" "),t("h4",{attrs:{id:"优化内存程序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化内存程序"}},[a._v("#")]),a._v(" 优化内存程序")]),a._v(" "),t("p",[a._v("如果库存卖完了，在程序内存里写一个库存是否售完的标记\n如果商品售完，不用请求缓存，直接返回商品已售完；")]),a._v(" "),t("h4",{attrs:{id:"下单失败的情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#下单失败的情况"}},[a._v("#")]),a._v(" 下单失败的情况")]),a._v(" "),t("p",[a._v("库存增加，先写数据库，再写缓存，再将商品售完标记置为false")]),a._v(" "),t("h3",{attrs:{id:"测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[a._v("#")]),a._v(" 测试")]),a._v(" "),t("p",[a._v("用jmeter或其他工具模拟并发，进行压测，保证系统质量")]),a._v(" "),t("h2",{attrs:{id:"设计一个缓存系统lru"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设计一个缓存系统lru"}},[a._v("#")]),a._v(" 设计一个缓存系统LRU")]),a._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，\n其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。")]),a._v(" "),t("h3",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：")]),a._v(" "),t("ol",[t("li",[a._v("新数据插入到链表头部；")]),a._v(" "),t("li",[a._v("每当缓存命中（即缓存数据被访问），则将数据移到链表头部；")]),a._v(" "),t("li",[a._v("当链表满的时候，将链表尾部的数据丢弃。")])]),a._v(" "),t("h3",{attrs:{id:"分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[a._v("#")]),a._v(" 分析")]),a._v(" "),t("p",[a._v("【命中率】")]),a._v(" "),t("p",[a._v("当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。")]),a._v(" "),t("p",[a._v("【复杂度】")]),a._v(" "),t("p",[a._v("实现简单。")]),a._v(" "),t("p",[a._v("【代价】")]),a._v(" "),t("p",[a._v("命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。当数据量较大时，遍历链表效率较低。")]),a._v(" "),t("h2",{attrs:{id:"实现-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现-2"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("有一种叫做有序字典的数据结构，综合了哈希表和链表，在 Python 中为 "),t("code",[a._v("OrderedDict")]),a._v(",在 Java 中为 "),t("code",[a._v("LinkedHashMap")]),a._v(",\n在javascript中的实现为"),t("code",[a._v("Map")])]),a._v(" "),t("h3",{attrs:{id:"python"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[a._v("#")]),a._v(" python")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('from collections import OrderedDict\nclass LRUCache(OrderedDict):\n\n    def __init__(self, capacity):\n        """\n        :type capacity: int\n        """\n        self.capacity = capacity\n\n    def get(self, key):\n        """\n        :type key: int\n        :rtype: int\n        """\n        if key not in self:\n            return - 1\n\n        self.move_to_end(key)\n        return self[key]\n\n    def put(self, key, value):\n        """\n        :type key: int\n        :type value: int\n        :rtype: void\n        """\n        if key in self:\n            self.move_to_end(key)\n        self[key] = value\n        if len(self) > self.capacity:\n            self.popitem(last = False)\n\n# LRUCache 对象会以如下语句构造和调用:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br"),t("span",{staticClass:"line-number"},[a._v("22")]),t("br"),t("span",{staticClass:"line-number"},[a._v("23")]),t("br"),t("span",{staticClass:"line-number"},[a._v("24")]),t("br"),t("span",{staticClass:"line-number"},[a._v("25")]),t("br"),t("span",{staticClass:"line-number"},[a._v("26")]),t("br"),t("span",{staticClass:"line-number"},[a._v("27")]),t("br"),t("span",{staticClass:"line-number"},[a._v("28")]),t("br"),t("span",{staticClass:"line-number"},[a._v("29")]),t("br"),t("span",{staticClass:"line-number"},[a._v("30")]),t("br"),t("span",{staticClass:"line-number"},[a._v("31")]),t("br"),t("span",{staticClass:"line-number"},[a._v("32")]),t("br"),t("span",{staticClass:"line-number"},[a._v("33")]),t("br"),t("span",{staticClass:"line-number"},[a._v("34")]),t("br"),t("span",{staticClass:"line-number"},[a._v("35")]),t("br"),t("span",{staticClass:"line-number"},[a._v("36")]),t("br"),t("span",{staticClass:"line-number"},[a._v("37")]),t("br")])]),t("p",[a._v("复杂度分析")]),a._v(" "),t("ul",[t("li",[a._v("时间复杂度：对于 put 和 get 操作复杂度是 O(1)O(1)，\n因为有序字典中的所有操作：get/in/set/move_to_end/popitem（get/containsKey/put/remove）都可以在常数时间内完成。")]),a._v(" "),t("li",[a._v("空间复杂度：O(capacity)，因为空间只用于有序字典存储最多 capacity + 1 个元素。")])]),a._v(" "),t("h3",{attrs:{id:"java"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[a._v("#")]),a._v(" java")]),a._v(" "),t("p",[a._v("java中最简单的LRU算法实现，就是利用jdk的LinkedHashMap，覆写其中的removeEldestEntry(Map.Entry)方法即可")]),a._v(" "),t("p",[a._v("如果你去看LinkedHashMap的源码可知，LRU算法是通过双向链表来实现，当某个位置被命中，通过调整链表的指向将该位置调整到头位置，\n新加入的内容直接放在链表头，如此一来，最近被命中的内容就向链表头移动，需要替换时，链表最后的位置就是最近最少使用的位置。")]),a._v(" "),t("h3",{attrs:{id:"golang"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#golang"}},[a._v("#")]),a._v(" golang")]),a._v(" "),t("p",[a._v("使用双向链表 + collection")]),a._v(" "),t("h3",{attrs:{id:"javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[a._v("#")]),a._v(" javascript")]),a._v(" "),t("p",[a._v("使用"),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/keys",target:"_blank",rel:"noopener noreferrer"}},[t("strong",[a._v("javascript ES6 Map中keys的有序性")]),t("OutboundLink")],1),a._v("来实现")]),a._v(" "),t("p",[a._v("一个Map对象在迭代时会根据对象中元素的插入顺序来进行")]),a._v(" "),t("ul",[t("li",[a._v("get操作")])]),a._v(" "),t("p",[a._v("如果元素存在，先delete再set, 元素便会成置为最新使用；如果不存在，返回-1")]),a._v(" "),t("ul",[t("li",[a._v("put操作")])]),a._v(" "),t("p",[a._v("如果元素存在，先delete再set, 元素便会成置为最新使用；\n如果容器超限，进行删除末尾元素操作，使用 Map{}.keys().next()得到迭代器的第一个元素，为使用时间最远的元素，进行删除")]),a._v(" "),t("div",{staticClass:"language-cpp line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-cpp"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n * @param {number} capacity\n */")]),a._v("\nvar LRUCache "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("constructor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("capacity"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("cache "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("Map")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("capacity "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" capacity"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n     * @param {number} key\n     * @return {number}\n     */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        let cache "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        let temp "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("temp"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("delete")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" temp"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" temp"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n     * @param {number} key\n     * @param {number} value\n     * @return {void}\n     */")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("put")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n        let cache "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("has")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("delete")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("size "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("capacity"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("delete")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("keys")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("next")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        cache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" value"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br"),t("span",{staticClass:"line-number"},[a._v("22")]),t("br"),t("span",{staticClass:"line-number"},[a._v("23")]),t("br"),t("span",{staticClass:"line-number"},[a._v("24")]),t("br"),t("span",{staticClass:"line-number"},[a._v("25")]),t("br"),t("span",{staticClass:"line-number"},[a._v("26")]),t("br"),t("span",{staticClass:"line-number"},[a._v("27")]),t("br"),t("span",{staticClass:"line-number"},[a._v("28")]),t("br"),t("span",{staticClass:"line-number"},[a._v("29")]),t("br"),t("span",{staticClass:"line-number"},[a._v("30")]),t("br"),t("span",{staticClass:"line-number"},[a._v("31")]),t("br"),t("span",{staticClass:"line-number"},[a._v("32")]),t("br"),t("span",{staticClass:"line-number"},[a._v("33")]),t("br"),t("span",{staticClass:"line-number"},[a._v("34")]),t("br"),t("span",{staticClass:"line-number"},[a._v("35")]),t("br"),t("span",{staticClass:"line-number"},[a._v("36")]),t("br"),t("span",{staticClass:"line-number"},[a._v("37")]),t("br"),t("span",{staticClass:"line-number"},[a._v("38")]),t("br"),t("span",{staticClass:"line-number"},[a._v("39")]),t("br"),t("span",{staticClass:"line-number"},[a._v("40")]),t("br"),t("span",{staticClass:"line-number"},[a._v("41")]),t("br"),t("span",{staticClass:"line-number"},[a._v("42")]),t("br"),t("span",{staticClass:"line-number"},[a._v("43")]),t("br"),t("span",{staticClass:"line-number"},[a._v("44")]),t("br"),t("span",{staticClass:"line-number"},[a._v("45")]),t("br"),t("span",{staticClass:"line-number"},[a._v("46")]),t("br"),t("span",{staticClass:"line-number"},[a._v("47")]),t("br"),t("span",{staticClass:"line-number"},[a._v("48")]),t("br"),t("span",{staticClass:"line-number"},[a._v("49")]),t("br")])]),t("h2",{attrs:{id:"其他更多的lru算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他更多的lru算法"}},[a._v("#")]),a._v(" 其他更多的LRU算法")]),a._v(" "),t("h2",{attrs:{id:"lru-k"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru-k"}},[a._v("#")]),a._v(" LRU-K")]),a._v(" "),t("h3",{attrs:{id:"原理-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理-2"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。\nLRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。")]),a._v(" "),t("h3",{attrs:{id:"实现-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现-3"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。\n只有当数据的访问次数达到K次的时候，才将数据放入缓存。\n当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：")]),a._v(" "),t("ol",[t("li",[a._v("数据第一次被访问，加入到访问历史列表；")]),a._v(" "),t("li",[a._v("如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；")]),a._v(" "),t("li",[a._v("当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；")]),a._v(" "),t("li",[a._v("缓存数据队列中被再次访问后，重新排序；")]),a._v(" "),t("li",[a._v("需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。")])]),a._v(" "),t("p",[a._v("LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，\nLRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。")]),a._v(" "),t("h3",{attrs:{id:"分析-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析-2"}},[a._v("#")]),a._v(" 分析")]),a._v(" "),t("p",[a._v("【命中率】")]),a._v(" "),t("p",[a._v("LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。")]),a._v(" "),t("p",[a._v("【复杂度】")]),a._v(" "),t("p",[a._v("LRU-K队列是一个优先级队列，算法复杂度和代价比较高。")]),a._v(" "),t("p",[a._v("【代价】")]),a._v(" "),t("p",[a._v("由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。")]),a._v(" "),t("p",[a._v("LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。")]),a._v(" "),t("h2",{attrs:{id:"two-queues（2q）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#two-queues（2q）"}},[a._v("#")]),a._v(" Two queues（2Q）")]),a._v(" "),t("h3",{attrs:{id:"原理-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理-3"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，\n即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。")]),a._v(" "),t("h3",{attrs:{id:"实现-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现-4"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，\n则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：")]),a._v(" "),t("ol",[t("li",[a._v("新访问的数据插入到FIFO队列；")]),a._v(" "),t("li",[a._v("如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；")]),a._v(" "),t("li",[a._v("如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；")]),a._v(" "),t("li",[a._v("如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；")]),a._v(" "),t("li",[a._v("LRU队列淘汰末尾的数据。")])]),a._v(" "),t("p",[t("strong",[a._v("注:")]),a._v("\n上图中FIFO队列比LRU队列短，但并不代表这是算法要求，实际应用中两者比例没有硬性规定。")]),a._v(" "),t("h3",{attrs:{id:"分析-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析-3"}},[a._v("#")]),a._v(" 分析")]),a._v(" "),t("p",[a._v("【命中率】")]),a._v(" "),t("p",[a._v("2Q算法的命中率要高于LRU。")]),a._v(" "),t("p",[a._v("复杂度】")]),a._v(" "),t("p",[a._v("需要两个队列，但两个队列本身都比较简单。")]),a._v(" "),t("p",[a._v("【代价】")]),a._v(" "),t("p",[a._v("FIFO和LRU的代价之和。")]),a._v(" "),t("p",[a._v("2Q算法和LRU-2算法命中率类似，内存消耗也比较接近，但对于最后缓存的数据来说，2Q会减少一次从原始存储读取数据或者计算数据的操作。")]),a._v(" "),t("h2",{attrs:{id:"multi-queue（mq）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multi-queue（mq）"}},[a._v("#")]),a._v(" Multi Queue（MQ）")]),a._v(" "),t("h3",{attrs:{id:"原理-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理-4"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),t("p",[a._v("MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：优先缓存访问次数多的数据。")]),a._v(" "),t("h3",{attrs:{id:"实现-5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现-5"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),t("p",[a._v("MQ算法将缓存划分为多个LRU队列，每个队列对应不同的访问优先级。访问优先级是根据访问次数计算出来的，例如")]),a._v(" "),t("p",[a._v("详细的算法结构图如下，Q0，Q1....Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列：")]),a._v(" "),t("p",[a._v("如上图，算法详细描述如下：")]),a._v(" "),t("ol",[t("li",[a._v("新插入的数据放入Q0；")]),a._v(" "),t("li",[a._v("每个队列按照LRU管理数据；")]),a._v(" "),t("li",[a._v("当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列删除，加入到高一级队列的头部；")]),a._v(" "),t("li",[a._v("为了防止高优先级数据永远不被淘汰，当数据在指定的时间里访问没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；")]),a._v(" "),t("li",[a._v("需要淘汰数据时，从最低一级队列开始按照LRU淘汰；每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部；")]),a._v(" "),t("li",[a._v("如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列的头部；")]),a._v(" "),t("li",[a._v("Q-history按照LRU淘汰数据的索引。")])]),a._v(" "),t("h3",{attrs:{id:"分析-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析-4"}},[a._v("#")]),a._v(" 分析")]),a._v(" "),t("p",[a._v("【命中率】")]),a._v(" "),t("p",[a._v("MQ降低了“缓存污染”带来的问题，命中率比LRU要高。")]),a._v(" "),t("p",[a._v("【复杂度】")]),a._v(" "),t("p",[a._v("MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。")]),a._v(" "),t("p",[a._v("【代价】")]),a._v(" "),t("p",[a._v("MQ需要记录每个数据的访问时间，需要定时扫描所有队列，代价比LRU要高。")]),a._v(" "),t("p",[a._v("注：虽然MQ的队列看起来数量比较多，但由于所有队列之和受限于缓存容量的大小，因此这里多个队列长度之和和一个LRU队列是一样的，因此队列扫描性能也相近。")]),a._v(" "),t("h2",{attrs:{id:"lru类算法对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lru类算法对比"}},[a._v("#")]),a._v(" LRU类算法对比")]),a._v(" "),t("p",[a._v("由于不同的访问模型导致命中率变化较大，此处对比仅基于理论定性分析，不做定量分析。")]),a._v(" "),t("p",[a._v("对比")]),a._v(" "),t("ul",[t("li",[a._v("命中率 LRU-2 > MQ(2) > 2Q > LRU")]),a._v(" "),t("li",[a._v("复杂度 LRU-2 > MQ(2) > 2Q > LRU")]),a._v(" "),t("li",[a._v("代价 LRU-2  > MQ(2) > 2Q > LRU")])]),a._v(" "),t("p",[a._v("实际应用中需要根据业务的需求和对数据的访问情况进行选择，并不是命中率越高越好。例如：虽然LRU看起来命中率会低一些，且存在”缓存污染“的问题，但由于其简单和代价小，实际应用中反而应用更多。")])])}),[],!1,null,null,null);s.default=e.exports}}]);