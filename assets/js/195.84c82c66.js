(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{367:function(v,_,t){"use strict";t.r(_);var s=t(42),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("缓存缓存雪崩、穿透、击穿问题")]),v._v(" "),t("p",[v._v("一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。")]),v._v(" "),t("h2",{attrs:{id:"缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),t("p",[t("strong",[v._v("缓存雪崩")]),v._v(", 即缓存"),t("strong",[v._v("同一时间大面积的失效")]),v._v("，这个时候又来了一波请求，结果请求都打到数据库上，从而导致数据库连接异常。")]),v._v(" "),t("h3",{attrs:{id:"缓存雪崩解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩解决方案"}},[v._v("#")]),v._v(" 缓存雪崩解决方案")]),v._v(" "),t("ul",[t("li",[v._v("平时开发： "),t("strong",[v._v("随机失效时间")]),v._v("；给缓存的失效时间，加上一个随机值，避免集体失效")]),v._v(" "),t("li",[v._v("redis的运维:\n"),t("ul",[t("li",[v._v("发生雪崩事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。")]),v._v(" "),t("li",[v._v("发生雪崩事中：本地"),t("code",[v._v("ehcache")]),v._v("缓存 + "),t("code",[v._v("hystrix")]),v._v(" "),t("strong",[v._v("限流&降级")]),v._v("，避免 MySQL 被打死。")]),v._v(" "),t("li",[v._v("发生雪崩事后：redis持久化（RDB+AOF)，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。")])])])]),v._v(" "),t("h2",{attrs:{id:"缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[v._v("#")]),v._v(" 缓存穿透")]),v._v(" "),t("p",[t("strong",[v._v("缓存穿透")]),v._v("，即黑客故意去"),t("strong",[v._v("请求缓存中不存在的数据")]),v._v("，导致所有的请求都怼到数据库上，从而数据库连接异常。")]),v._v(" "),t("p",[v._v("低频的缓存穿透是 正常的，高频的缓存穿透才会影响数据库")]),v._v(" "),t("h3",{attrs:{id:"缓存穿透解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透解决方案"}},[v._v("#")]),v._v(" 缓存穿透解决方案")]),v._v(" "),t("ol",[t("li",[v._v("同样的请求ID的情况；\n"),t("ul",[t("li",[t("strong",[v._v("分布式锁")]),v._v("，使用"),t("strong",[v._v("互斥锁")]),v._v("更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。")]),v._v(" "),t("li",[v._v("把查询到的结果（正常查询结果、NULL值等）写入到缓存中，可以过滤掉同样的请求")])])]),v._v(" "),t("li",[v._v("每次都是 不同的ID（最常见的攻击场景）；\n"),t("ul",[t("li",[v._v("利用"),t("strong",[v._v("布隆过滤器")]),v._v("迅速判断请求所携带的 Key 是否合法有效，如果不合法，则直接返回；")])])])]),v._v(" "),t("h2",{attrs:{id:"缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[v._v("#")]),v._v(" 缓存击穿")]),v._v(" "),t("p",[t("strong",[v._v("缓存击穿")]),v._v("，就是"),t("strong",[v._v("某个热点数据失效")]),v._v("时，大量针对这个数据的请求会穿透到数据源。")]),v._v(" "),t("h3",{attrs:{id:"缓存击穿解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿解决方案"}},[v._v("#")]),v._v(" 缓存击穿解决方案")]),v._v(" "),t("ul",[t("li",[v._v("分布式锁，当热点数据失效的时候，去查询数据库时加上"),t("strong",[v._v("分布式锁")])])])])}),[],!1,null,null,null);_.default=r.exports}}]);