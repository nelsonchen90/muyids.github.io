(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{544:function(v,_,a){"use strict";a.r(_);var s=a(42),t=Object(s.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("ul",[a("li",[a("a",{attrs:{href:"#B-Tree%E5%92%8CB+Tree%E7%9A%84%E5%8C%BA%E5%88%AB"}},[v._v("B-Tree和B+Tree的区别")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"}},[v._v("聚簇索引和非聚簇索引")])])]),v._v(" "),a("p",[v._v("数据库的隔离级别，MySQL怎么解决幻读问题的？\n？B+Tree的优势\nB+ 树数据都存放在叶子节点，非叶子节点只存放索引，B+树更少得磁盘IO")]),v._v(" "),a("p",[v._v("联合索引、最左匹配原则")]),v._v(" "),a("p",[v._v("你项目中数据库表是怎么设计的，数据库三范式知道吗？\n介绍下数据库的锁，你在项目中是怎么用的？\n索引有哪些实现方式？说说他们的优缺点\nMySQL一般用的什么索引？介绍下......为什么不用 Hash索引？\nB+ 树")]),v._v(" "),a("p",[v._v("十一、举出几个 你做过的分库分表的实例。\n十二、你通常是如何优化mysql的查询？\n十三、你们项目中用到了redis的那些方法，set 和 mset的区别？\n十四、Mysql的索引是如何实现的。\n十五、举例写出一个Mysql储存过程和一个事务。")]),v._v(" "),a("hr"),v._v(" "),a("h2",{attrs:{id:"b-tree和b-tree的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-tree和b-tree的区别"}},[v._v("#")]),v._v(" B-Tree和B+Tree的区别")]),v._v(" "),a("h2",{attrs:{id:"数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[v._v("#")]),v._v(" 数据库")]),v._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81ACID"}},[v._v("事务的四大特征ACID")])]),v._v(" "),a("li",[a("a",{attrs:{href:"#CAS%E7%AE%97%E6%B3%95"}},[v._v("CAS算法")])])]),v._v(" "),a("h2",{attrs:{id:"cas算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cas算法"}},[v._v("#")]),v._v(" CAS算法")]),v._v(" "),a("p",[v._v("campare and set")]),v._v(" "),a("p",[v._v("CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。\n当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。\n这个过程是原子性的。")]),v._v(" "),a("p",[v._v("乐观锁用到的就是CAS算法")]),v._v(" "),a("p",[v._v("findAndUpdate 操作 就是 CAS算法")]),v._v(" "),a("p",[v._v("update xxxx where xx = ? 就是 CAS算法")]),v._v(" "),a("hr"),v._v(" "),a("p",[v._v("乐观锁不能解决脏读")]),v._v(" "),a("hr"),v._v(" "),a("h3",{attrs:{id:"数据库-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库-2"}},[v._v("#")]),v._v(" 数据库")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("用过哪些数据库（MySQL、MongoDB、Redis）")])]),v._v(" "),a("li",[a("p",[v._v("MySQL查询优化、索引、索引的原理")])]),v._v(" "),a("li",[a("p",[v._v("MySQL库设计一个简单的论坛系统，画出用户表、帖子表、评论表的er图，")]),v._v(" "),a("p",[v._v("当用户量很大时，如何优化，缓存最多存一万条数据时如何优化(使用LRU缓存)")])]),v._v(" "),a("li",[a("p",[v._v("MySQL的配置文件改过哪些参数")])]),v._v(" "),a("li",[a("p",[v._v("MySQL及MongoDB如何选择，选择的标准是什么")])]),v._v(" "),a("li",[a("p",[v._v("MongoDB的聚合函数，用到过哪些参数")])]),v._v(" "),a("li",[a("p",[v._v("MongoDB的几种索引，数据量特别大时的分片")])]),v._v(" "),a("li",[a("p",[v._v("数据库的灾备（MySQL、MongoDB）")])])]),v._v(" "),a("h2",{attrs:{id:"innodb的隔离级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb的隔离级别"}},[v._v("#")]),v._v(" InnoDB的隔离级别")]),v._v(" "),a("h2",{attrs:{id:"mongodb和mysql的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mongodb和mysql的区别"}},[v._v("#")]),v._v(" mongodb和mysql的区别")]),v._v(" "),a("h3",{attrs:{id:"mysql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[v._v("#")]),v._v(" mysql")]),v._v(" "),a("ol",[a("li",[v._v("mysql是关系型数据库")]),v._v(" "),a("li",[v._v("在不同的引擎上有不同的存储方式。常用的是InnoDB，支持事务")]),v._v(" "),a("li",[v._v("查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。")]),v._v(" "),a("li",[v._v("开源数据库的份额在不断增加，mysql的份额也在持续增长。")]),v._v(" "),a("li",[v._v("缺点就是在海量数据处理的时候效率会显著变慢。")])]),v._v(" "),a("h2",{attrs:{id:"mongodb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mongodb"}},[v._v("#")]),v._v(" mongodb")]),v._v(" "),a("ol",[a("li",[v._v("非关系型数据库(nosql), 属于文档型数据库。可以存放xml、json、bson类型的数据")]),v._v(" "),a("li",[v._v("这些数据具备自述性（self-describing），呈现分层的树状数据结构。数据结构由键值(key=>value)对组成。")]),v._v(" "),a("li",[v._v("存储方式：虚拟内存+持久化。")]),v._v(" "),a("li",[v._v("查询语句：是独特的Mongodb的查询方式。可以写javascript脚本查询")]),v._v(" "),a("li",[v._v("适合场景：事件的记录，内容管理或者博客平台等等。")]),v._v(" "),a("li",[v._v("架构特点：可以通过副本集，以及分片来实现高可用。")]),v._v(" "),a("li",[v._v("数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。")]),v._v(" "),a("li",[v._v("成熟度与广泛度：新兴数据库，成熟度较低，Nosql数据库中最为接近关系型数据库，比较完善的DB之一，适用人群不断在增长。")])]),v._v(" "),a("p",[v._v("优势：")]),v._v(" "),a("ol",[a("li",[v._v("快速。在适量级的内存的Mongodb的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快，")]),v._v(" "),a("li",[v._v("高扩展！")]),v._v(" "),a("li",[v._v("自身的Failover机制（失效转移）")]),v._v(" "),a("li",[v._v("json的存储格式")])]),v._v(" "),a("p",[v._v("缺点：主要是无事物机制！(4.0以后已加入事务机制)")]),v._v(" "),a("p",[v._v("分析一下Mysql和Mongodb应用场景")]),v._v(" "),a("ol",[a("li",[v._v("如果需要将mongodb作为后端db来代替mysql使用，即这里mysql与mongodb 属于平行级别，那么，这样的使用可能有以下几种情况的考量:")])]),v._v(" "),a("ul",[a("li",[v._v("mongodb所负责部分以文档形式存储，能够有较好的代码亲和性，json格式的直接写入方便。(如日志之类)")]),v._v(" "),a("li",[v._v("从data models设计阶段就将原子性考虑于其中，无需事务之类的辅助。开发用如nodejs之类的语言来进行开发，对开发比较方便。")]),v._v(" "),a("li",[v._v("mongodb本身的failover机制，无需使用如MHA之类的方式实现。")])]),v._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[v._v("将mongodb作为类似redis，memcache来做缓存db，为mysql提供服务，或是后端日志收集分析。\n考虑到mongodb属于nosql型数据库，sql语句与数据结构不如mysql那么亲和 ，也会有很多时候将mongodb做为辅助mysql而使用的类redis memcache 之类的缓存db来使用。\n亦或是仅作日志收集分析。")])]),v._v(" "),a("h2",{attrs:{id:"数据一致性，高可用性，性能的矛盾"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性，高可用性，性能的矛盾"}},[v._v("#")]),v._v(" 数据一致性，高可用性，性能的矛盾")]),v._v(" "),a("p",[v._v("1）要想让数据有高可用性，就得写多份数据\n2）写多份的问题会导致数据一致性的问题\n3）数据一致性的问题又会引发性能问题\n强一致性必然导致性能短板, 而弱一致性则有很好的性能但是存在数据安全(灾备数据丢失)/一致性(脏读/脏写等)的问题.")]),v._v(" "),a("p",[v._v("目前 Node.js 业内流行的主要是与 Mongodb 配合, 在数据一致性方面属于短板.")]),v._v(" "),a("h2",{attrs:{id:"事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[v._v("#")]),v._v(" 事务")]),v._v(" "),a("p",[v._v('事务在分布式的问题中可以称为 "两阶段提交"')]),v._v(" "),a("p",[v._v("第一阶段：")]),v._v(" "),a("p",[v._v("协调者会问所有的参与者结点，是否可以执行提交操作。\n各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……\n参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。")]),v._v(" "),a("p",[v._v("第二阶段：")]),v._v(" "),a("p",[v._v("如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。\n如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。")]),v._v(" "),a("p",[v._v("异常:")]),v._v(" "),a("p",[v._v("如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。\n如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。\n第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办。")]),v._v(" "),a("h2",{attrs:{id:"事务的四大特征acid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务的四大特征acid"}},[v._v("#")]),v._v(" 事务的四大特征ACID")]),v._v(" "),a("p",[v._v("原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）")]),v._v(" "),a("ul",[a("li",[v._v("原子性（Atomicity)\n要么全部成功,要么全部失败.不可能只执行一部分操作.")]),v._v(" "),a("li",[v._v("一致性（Consistency）\n系统(数据库)总是从一个一致性的状态转移到另一个一致性的状态,不会存在中间状态.")]),v._v(" "),a("li",[v._v("隔离性（Isolation）\n通常来说:一个事务在完全提交之前,对其他事务是不可见的.也有例外情况")]),v._v(" "),a("li",[v._v("持久性（Durability）\n一旦事务提交,那么就永远是这样子了,哪怕系统崩溃也不会影响到这个事务的结果")])]),v._v(" "),a("h2",{attrs:{id:"cas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cas"}},[v._v("#")]),v._v(" CAS")]),v._v(" "),a("p",[v._v("compare and swap")]),v._v(" "),a("p",[v._v("先比较，看是否是旧值，再交换成新值")]),v._v(" "),a("h2",{attrs:{id:"aba问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aba问题"}},[v._v("#")]),v._v(" ABA问题")]),v._v(" "),a("p",[v._v("CAS不能防止ABA问题。\nABA问题。（一个值从A变成B，又更新回A，普通CAS会误判通过检测。利用版本号机制可以解决ABA问题。）")])])}),[],!1,null,null,null);_.default=t.exports}}]);