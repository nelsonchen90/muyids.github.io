(window.webpackJsonp=window.webpackJsonp||[]).push([[199],{361:function(v,_,t){"use strict";t.r(_);var s=t(42),l=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"redis持久化和主从复制原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化和主从复制原理"}},[v._v("#")]),v._v(" Redis持久化和主从复制原理")]),v._v(" "),t("p",[v._v("持久化的两种方式：RDB + AOF")]),v._v(" "),t("ul",[t("li",[v._v("RDB：RDB 持久化机制，是对 Redis 中的数据执行周期性的全局持久化。")]),v._v(" "),t("li",[v._v("AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog。")])]),v._v(" "),t("p",[v._v("RDB更适合做"),t("strong",[v._v("冷备")]),v._v("，AOF更适合做"),t("strong",[v._v("热备")])]),v._v(" "),t("p",[t("strong",[v._v("tip：两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。")])]),v._v(" "),t("h3",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),t("p",[v._v("优点：")]),v._v(" "),t("ul",[t("li",[v._v("可以恢复到之前某一时间点的数据")]),v._v(" "),t("li",[v._v("数据恢复的时候速度比AOF来的快。")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("默认五分钟甚至更久的时间才会生成一次，意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。AOF则最多丢一秒的数据")]),v._v(" "),t("li",[v._v("RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒")])]),v._v(" "),t("h3",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),t("p",[v._v("优点：")]),v._v(" "),t("ul",[t("li",[v._v("AOF是一秒一次去通过一个后台的线程fsync操作，最多丢一秒的数据")]),v._v(" "),t("li",[v._v("AOF在对日志文件进行操作的时候是以"),t("code",[v._v("append-only")]),v._v("的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。")]),v._v(" "),t("li",[t("strong",[v._v("适合做灾难性数据误删除的紧急恢复")]),v._v(";AOF的日志是通过一个叫非常可读的方式记录的，这样的特性就适合做灾难性数据误删除的紧急恢复了，比如公司的实习生通过flushall清空了所有的数据，只要这个时候"),t("strong",[v._v("后台重写还没发生")]),v._v("，你马上拷贝一份AOF日志文件，把最后一条flushall命令删了就完事了。")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ul",[t("li",[v._v("一样的数据，AOF文件比RDB还要大。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);