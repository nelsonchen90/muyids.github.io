(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{422:function(t,a,r){"use strict";r.r(a);var e=r(42),o=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("一个 partition 只能由一个 consumer 消费")]),t._v(" "),r("p",[t._v("由于 一个 "),r("code",[t._v("consumer group")]),t._v("中有多个"),r("code",[t._v("consumer")]),t._v("，一个"),r("code",[t._v("topic")]),t._v("有多个"),r("code",[t._v("partition")]),t._v("，需要进行"),r("code",[t._v("partition")]),t._v("的分配，确定哪个"),r("code",[t._v("partition")]),t._v("由哪个"),r("code",[t._v("consumer")]),t._v("来消费")]),t._v(" "),r("h1",{attrs:{id:"两种分配策略：roundrobin和range"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两种分配策略：roundrobin和range"}},[t._v("#")]),t._v(" 两种分配策略："),r("code",[t._v("RoundRobin")]),t._v("和"),r("code",[t._v("Range")])]),t._v(" "),r("h2",{attrs:{id:"roundrobin-轮询分区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#roundrobin-轮询分区"}},[t._v("#")]),t._v(" RoundRobin 轮询分区")]),t._v(" "),r("p",[t._v("使用RoundRobin 轮询分区策略，必须满足如下两个条件：")]),t._v(" "),r("ol",[r("li",[t._v("每个消费者订阅的主题，必须是相同的")]),t._v(" "),r("li",[t._v("每个主题的消费者实例都是相同的")])]),t._v(" "),r("h2",{attrs:{id:"range-范围分区（默认）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#range-范围分区（默认）"}},[t._v("#")]),t._v(" Range 范围分区（默认）")]),t._v(" "),r("p",[t._v("Range 范围分区策略是对每个 topic 而言的。首先对同一个 topic 里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。假如现在有 10 个分区，3 个消费者，排序后的分区将会是0,1,2,3,4,5,6,7,8,9；消费者排序完之后将会是C1-0,C2-0,C3-0。通过 partitions数/consumer数 来决定每个消费者应该消费几个分区。如果除不尽，那么前面几个消费者将会多消费 1 个分区。")]),t._v(" "),r("p",[t._v("Range 范围分区的弊端：")]),t._v(" "),r("p",[t._v("如上，只是针对 1 个 topic 而言，C1-0消费者多消费1个分区影响不是很大。如果有 N 多个 topic，那么针对每个 topic，消费者 C1-0 都将多消费 1 个分区，topic越多，C1-0 消费的分区会比其他消费者明显多消费 N 个分区。这就是 Range 范围分区的一个很明显的弊端了")]),t._v(" "),r("h2",{attrs:{id:"sticky-assignor-after-0-11"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sticky-assignor-after-0-11"}},[t._v("#")]),t._v(" Sticky Assignor(after 0.11)")]),t._v(" "),r("p",[t._v("解决应用宕机或重启的时候，上述两种方式会重复消费")]),t._v(" "),r("p",[t._v("基于RoundRobin做初始化分发")]),t._v(" "),r("h1",{attrs:{id:"什么时候触发分区分配策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么时候触发分区分配策略"}},[t._v("#")]),t._v(" 什么时候触发分区分配策略")]),t._v(" "),r("p",[t._v("当出现以下几种情况时，Kafka 会进行一次分区分配操作，即 Kafka 消费者端的 Rebalance 操作")]),t._v(" "),r("ol",[r("li",[t._v("同一个 consumer 消费者组 group.id 中，新增了消费者进来，会执行 Rebalance 操作")]),t._v(" "),r("li",[t._v("消费者离开当期所属的 consumer group组。比如 主动停机  或者  宕机")]),t._v(" "),r("li",[t._v("分区数量发生变化时(即 topic 的分区数量发生变化时)")]),t._v(" "),r("li",[t._v("消费者主动取消订阅")])]),t._v(" "),r("h1",{attrs:{id:"阅读"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#阅读"}},[t._v("#")]),t._v(" 阅读")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://blog.csdn.net/lzb348110175/article/details/100773487",target:"_blank",rel:"noopener noreferrer"}},[t._v("8.Kafka 分区分配策略（Range分配策略 && RoundRobin分配策略）"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=o.exports}}]);