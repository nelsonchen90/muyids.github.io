(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{381:function(v,_,a){"use strict";a.r(_);var s=a(42),h=Object(s.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("p",[v._v("索引是帮助数据库高效搜索的数据结构")]),v._v(" "),a("h2",{attrs:{id:"索引数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引数据结构"}},[v._v("#")]),v._v(" 索引数据结构")]),v._v(" "),a("ul",[a("li",[v._v("二叉树")]),v._v(" "),a("li",[v._v("红黑树")]),v._v(" "),a("li",[v._v("B+Tree")]),v._v(" "),a("li",[v._v("hash表")]),v._v(" "),a("li",[v._v("全文索引（倒排索引）")])]),v._v(" "),a("h2",{attrs:{id:"索引类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引类型"}},[v._v("#")]),v._v(" 索引类型")]),v._v(" "),a("ul",[a("li",[v._v("普通索引")]),v._v(" "),a("li",[v._v("唯一索引")]),v._v(" "),a("li",[v._v("主键索引")]),v._v(" "),a("li",[v._v("复合索引")]),v._v(" "),a("li",[v._v("全文索引")])]),v._v(" "),a("h2",{attrs:{id:"b-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-tree"}},[v._v("#")]),v._v(" B+Tree")]),v._v(" "),a("p",[v._v("多叉平衡树")]),v._v(" "),a("p",[v._v("B-Tree的变种，与B-Tree的区别")]),v._v(" "),a("ul",[a("li",[v._v("非叶子节点不存储data，只存储索引（冗余）,可以放更多的索引")]),v._v(" "),a("li",[v._v("叶子节点包含所有索引字段")]),v._v(" "),a("li",[v._v("叶子节点用指针连接，提高区间访问的性能")])]),v._v(" "),a("h2",{attrs:{id:"hash索引和b-树索引有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash索引和b-树索引有什么区别"}},[v._v("#")]),v._v(" hash索引和B+树索引有什么区别")]),v._v(" "),a("p",[v._v("hash索引底层就是hash表，查询时，通过hash函数计算出数据存储位置，从而获得实际数据。\nB+树底层实现是 多路平衡查找树，对于每一次查询都是从根节点出发，向下查找，直到查找到叶子节点，得到要查询的数据。")]),v._v(" "),a("ul",[a("li",[v._v("hash索引查询效率更高")]),v._v(" "),a("li",[v._v("hash索引无法排序")]),v._v(" "),a("li",[v._v("hash索引无法根据前缀查询，如like 'aaa%'")]),v._v(" "),a("li",[v._v("hash索引无法用于比较")]),v._v(" "),a("li",[v._v("hash索引虽然在等值查询上较快,但是不稳定,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差。\nB+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.")])]),v._v(" "),a("h2",{attrs:{id:"数据库索引为什么不用hash表而用b-树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库索引为什么不用hash表而用b-树"}},[v._v("#")]),v._v(" 数据库索引为什么不用hash表而用b+树")]),v._v(" "),a("ol",[a("li",[v._v("hash表只能匹配是否相等，不能实现范围查找\nselect * from xx where id > 23; 这时就没办法索引了")]),v._v(" "),a("li",[v._v("当需要按照索引进行order by时，hash值没办法支持排序\nselect * from xx order by score desc;\n如果score为建立索引的字段，hash值没办法辅助排序。")]),v._v(" "),a("li",[v._v("B树种的组合索引可以支持部分索引查询\n如(a,b,c)的组合索引，查询中只用到了a和b也可以查询的，\n如果使用hash表，组合索引会将几个字段合并hash，没办法支持部分索引")]),v._v(" "),a("li",[a("strong",[v._v("当数据量很大时，hash冲突的概率也会非常大")])])]),v._v(" "),a("h2",{attrs:{id:"什么情况下无法使用索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下无法使用索引"}},[v._v("#")]),v._v(" 什么情况下无法使用索引")]),v._v(" "),a("ul",[a("li",[v._v("列参与了数学运算或者函数")]),v._v(" "),a("li",[v._v("在字符串like时左边是通配符.类似于'%aaa'.")]),v._v(" "),a("li",[v._v("当mysql分析全表扫描比使用索引快的时候不使用索引.")]),v._v(" "),a("li",[v._v("当使用联合索引,前面一个条件为范围查询,后面的即使符合最左前缀原则,也无法使用索引.")])]),v._v(" "),a("h2",{attrs:{id:"常见索引列建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见索引列建议"}},[v._v("#")]),v._v(" 常见索引列建议")]),v._v(" "),a("ul",[a("li",[v._v("出现在SELECT、UPDATE、DELETE语句的WHERE从句中的列")]),v._v(" "),a("li",[v._v("包含在ORDER BY、GROUP BY、DISTINCT中的字段")]),v._v(" "),a("li",[v._v("并不要将符合1和2中的字段的列都建立一个索引，通常将1、2中的字段建立联合索引效果更好")]),v._v(" "),a("li",[v._v("多表join的关联列")]),v._v(" "),a("li",[v._v("限制每张表上的索引数量，建议单张表索引不超过 5个")]),v._v(" "),a("li",[v._v("每个Innodb表必须有个主键")])]),v._v(" "),a("p",[v._v("主键选择：")]),v._v(" "),a("ul",[a("li",[v._v("不要使用更新频繁的列作为主键")]),v._v(" "),a("li",[v._v("不适用多列主键（相当于联合索引）")]),v._v(" "),a("li",[v._v("不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长")]),v._v(" "),a("li",[v._v("主键建议使用自增或趋势递增的int类型ID值")])]),v._v(" "),a("h2",{attrs:{id:"如何选择索引列的顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何选择索引列的顺序"}},[v._v("#")]),v._v(" 如何选择索引列的顺序")]),v._v(" "),a("p",[v._v("建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。")]),v._v(" "),a("ul",[a("li",[v._v("区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）")]),v._v(" "),a("li",[v._v("尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；")]),v._v(" "),a("li",[v._v("使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。")])])])}),[],!1,null,null,null);_.default=h.exports}}]);