(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{497:function(t,e,a){"use strict";a.r(e);var s=a(42),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"拓扑排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拓扑排序"}},[t._v("#")]),t._v(" 拓扑排序")]),t._v(" "),a("h2",{attrs:{id:"应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),a("p",[t._v("拓扑排序的一个重要应用："),a("code",[t._v("判断AOV网中是否存在环")]),t._v("。对有向图构造拓扑排序，如果所有顶点都在它的拓扑序列中，则该AOV网必定不存在环。")]),t._v(" "),a("h2",{attrs:{id:"算法过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法过程"}},[t._v("#")]),t._v(" 算法过程")]),t._v(" "),a("ol",[a("li",[t._v("在图中找到一个入度为0的点，加入到维护的结果队列")]),t._v(" "),a("li",[t._v("对图进行拆点操作，拆掉这个点和所有相连的边")]),t._v(" "),a("li",[t._v("重复上面的两步，所有点都已拆除（拓扑序列中已经包含所有点）")])]),t._v(" "),a("p",[t._v("拓扑排序实际上是BFS的一种特殊情况，每次加入队列的点是"),a("code",[t._v("入度为0")]),t._v("的点，加入队列后拆掉相邻的边；记录已经拆掉的点")]),t._v(" "),a("h2",{attrs:{id:"练习题目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#练习题目"}},[t._v("#")]),t._v(" 练习题目")]),t._v(" "),a("ul",[a("li",[a("p",[a("RouterLink",{attrs:{to:"/alg/graph/problems/201-300/207.course-schedule.html"}},[t._v("LeetCode 207. Course Schedule (medium)")])],1)]),t._v(" "),a("li",[a("p",[a("RouterLink",{attrs:{to:"/alg/graph/problems/201-300/210.course-schedule-ii.html"}},[t._v("LeetCode 210. Course Schedule II (medium)")])],1)]),t._v(" "),a("li",[a("p",[a("RouterLink",{attrs:{to:"/alg/graph/problems/801-900/802.find-eventual-safe-states.html"}},[t._v("LeetCode 802. Find Eventual Safe States (medium)")])],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);