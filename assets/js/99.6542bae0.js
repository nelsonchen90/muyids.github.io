(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{559:function(v,a,_){"use strict";_.r(a);var s=_(42),t=Object(s.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("code",[v._v("一致性哈希")]),v._v("常用来解决"),_("code",[v._v("单点的不稳定性问题")])]),v._v(" "),_("h2",{attrs:{id:"算法原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法原理"}},[v._v("#")]),v._v(" 算法原理")]),v._v(" "),_("p",[v._v("先构造一个长度为232的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 232-1]）将服务器节点放置在这个Hash环上，\n然后根据数据的Key值计算得到其Hash值（其分布也为[0, 232-1]），\n接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。")]),v._v(" "),_("p",[v._v("这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。")]),v._v(" "),_("p",[v._v("一致性Hash算法比普通的余数Hash算法更具有伸缩性，但是同时其算法实现也更为复杂。")]),v._v(" "),_("h2",{attrs:{id:"数据结构的选取"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据结构的选取"}},[v._v("#")]),v._v(" 数据结构的选取")]),v._v(" "),_("p",[v._v("一致性Hash算法最先要考虑的一个问题是：构造出一个长度为232的整数环，根据节点名称的Hash值将服务器节点放置在这个Hash环上。")]),v._v(" "),_("p",[v._v("那么，整数环应该使用何种数据结构，才能使得运行时的时间复杂度最低？")]),v._v(" "),_("p",[v._v("首先说明一点，关于时间复杂度，常见的时间复杂度与时间效率的关系有如下的经验规则：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("O(1) < O(log2N) < O(n) < O(N * log2N) < O(N2) < O(N3) < 2N < 3N < N!\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("一般来说，前四个效率比较高，中间两个差强人意，后三个比较差（只要N比较大，这个算法就动不了了）。\nOK，继续前面的话题，应该如何选取数据结构，我认为有以下几种可行的解决方案。")]),v._v(" "),_("h3",{attrs:{id:"解决方案一：排序-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案一：排序-list"}},[v._v("#")]),v._v(" 解决方案一：排序+List")]),v._v(" "),_("p",[v._v("我想到的第一种思路是：算出所有待加入数据结构的节点名称的Hash值放入一个数组中，然后使用某种排序算法将其从小到大进行排序，\n最后将排序后的数据放入List中，采用List而不是数组是为了结点的扩展考虑。")]),v._v(" "),_("p",[v._v("之后，待路由的结点，只需要在List中找到第一个Hash值比它大的服务器节点就可以了，\n比如服务器节点的Hash值是"),_("code",[v._v("[0,2,4,6,8,10]")]),v._v("，带路由的结点是7，只需要找到第一个比7大的整数，也就是8，就是我们最终需要路由过去的服务器节点。")]),v._v(" "),_("p",[v._v("如果暂时不考虑前面的排序，那么这种解决方案的时间复杂度：")]),v._v(" "),_("p",[v._v("（1）最好的情况是第一次就找到，时间复杂度为O(1)")]),v._v(" "),_("p",[v._v("（2）最坏的情况是最后一次才找到，时间复杂度为O(N)")]),v._v(" "),_("p",[v._v("平均下来时间复杂度为O(0.5N+0.5)，忽略首项系数和常数，时间复杂度为O(N)。")]),v._v(" "),_("p",[v._v("但是如果考虑到之前排序算法的时间复杂度：")]),v._v(" "),_("p",[_("img",{attrs:{src:"/image/sort-o.png",alt:"各种常用排序算法"}})]),v._v(" "),_("p",[v._v("看得出来，排序算法要么稳定但是时间复杂度高、要么时间复杂度低但不稳定，最好的时间复杂度仍然有O(N*logN)")]),v._v(" "),_("h3",{attrs:{id:"解决方案二：遍历-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案二：遍历-list"}},[v._v("#")]),v._v(" 解决方案二：遍历+List")]),v._v(" "),_("p",[v._v("既然排序操作比较耗性能，那么能不能不排序？可以的，所以进一步的，有了第二种解决方案。")]),v._v(" "),_("p",[v._v("解决方案使用List不变，不过可以采用遍历的方式：")]),v._v(" "),_("p",[v._v("（1）服务器节点不排序，其Hash值全部直接放入一个List中")]),v._v(" "),_("p",[v._v("（2）带路由的节点，算出其Hash值，由于指明了”顺时针”，因此遍历List，比待路由的节点Hash值大的算出差值并记录，比待路由节点Hash值小的忽略")]),v._v(" "),_("p",[v._v("（3）算出所有的差值之后，最小的那个，就是最终需要路由过去的节点")]),v._v(" "),_("p",[v._v("在这个算法中，看一下时间复杂度：")]),v._v(" "),_("p",[v._v("1、最好情况是只有一个服务器节点的Hash值大于带路由结点的Hash值，其时间复杂度是O(N)+O(1)=O(N+1)，忽略常数项，即O(N)")]),v._v(" "),_("p",[v._v("2、最坏情况是所有服务器节点的Hash值都大于带路由结点的Hash值，其时间复杂度是O(N)+O(N)=O(2N)，忽略首项系数，即O(N)")]),v._v(" "),_("p",[v._v("所以，总的时间复杂度就是O(N)。其实算法还能更改进一些：给一个位置变量X，如果新的差值比原差值小，X替换为新的位置，否则X不变。这样遍历就减少了一轮，不过经过改进后的算法时间复杂度仍为O(N)。")]),v._v(" "),_("p",[v._v("总而言之，这个解决方案和解决方案一相比，总体来看，似乎更好了一些。")]),v._v(" "),_("h3",{attrs:{id:"解决方案三：二叉查找树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案三：二叉查找树"}},[v._v("#")]),v._v(" 解决方案三：二叉查找树")]),v._v(" "),_("p",[v._v("抛开List这种数据结构，另一种数据结构则是使用二叉查找树。")]),v._v(" "),_("p",[v._v("当然我们不能简单地使用二叉查找树，因为可能出现不平衡的情况。平衡二叉查找树有AVL树、红黑树等，这里使用红黑树，选用红黑树的原因有两点：")]),v._v(" "),_("p",[v._v("1、红黑树主要的作用是用于存储有序的数据，这其实和第一种解决方案的思路又不谋而合了，但是它的效率非常高")]),v._v(" "),_("p",[v._v("2、JDK里面提供了红黑树的代码实现TreeMap和TreeSet")]),v._v(" "),_("p",[v._v("另外，以TreeMap为例，TreeMap本身提供了一个tailMap(K fromKey)方法，支持从红黑树中查找比fromKey大的值的集合，但并不需要遍历整个数据结构。")]),v._v(" "),_("p",[v._v("使用红黑树，可以使得查找的时间复杂度降低为O(logN)，比上面两种解决方案，效率大大提升。")]),v._v(" "),_("p",[v._v("红黑树的数据结构决定了任何一个大于N的最小数据，它都只需要几次至几十次查找就可以查到。")]),v._v(" "),_("p",[v._v("当然，明确一点，有利必有弊，根据我另外一次测试得到的结论是，为了维护红黑树，数据插入效率TreeMap在三种数据结构里面是最差的，且插入要慢上5~10倍。")]),v._v(" "),_("h2",{attrs:{id:"应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[v._v("#")]),v._v(" 应用")]),v._v(" "),_("ul",[_("li",[v._v("数据分片")]),v._v(" "),_("li",[v._v("memcache")]),v._v(" "),_("li",[v._v("Cassandra数据库")])])])}),[],!1,null,null,null);a.default=t.exports}}]);